#!/bin/bash
version="0.10"
log_buffer+=('' 'START')
## Buffermaker
# Pure bash tui framework (wip)

shopt -s lastpipe # For syntax highlighting
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize && (:;:) # Enable and then trigger a terminal size refresh

declare -r DEFIFS="$IFS"
declare -A highlight faces faces_raw options charmap alias descriptions
declare -A menulineedit diredmenu menulinedebug
declare -A menufancy
declare -A keys_def keys_global
declare -a k_hex buffers_l log_buffer extensions modes=('keys_global')
declare -n buffer bf_s bf_e bf_d
declare -i menuloc_x menuloc_y toplines bottomlines hidden ismenu comment current_count _isdone
declare -n menucon
declare message reset readin

function load-default-config {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options → define-options() → ass. array options
	#				global-set → global-set-key → define-key global → as. ar. keys_global
	#				add-mode → local-set-key → define-key <keys> → a. a. keys_<keys>
	#					mode-options → local-set-mode-option → define-mode-option → a. a. key_options_<keys>
	#				set-alias → add-alias → a. a. alias
	#				add-menu → local-set-menu → define-menu <menu> → menu_<menu>_0 & menu_<menu>_1
	#				set-highlight → add-highlight → a. a. highlight
					  
	options=(
		[mouse]=0
		[todonote]=0
		[menu-line]=0
		[mode-line]=0
		[command-line]=0 # note that disabling this means that any message will instead be draw on top of buffer
		[line-number-mode]=0
		[empty-line-char]=''
		[tabchar]='    '
		[keep-message]=0
		[log]=0
		[log-functions]=0
		[tty-linuxfb]=1 # enable truecolor support for framebuffer
		[full-redraw]=0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		[esc-to-meta]=0
	)
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	add-mode empty
		mode-options
			:: else :
			:: disable-global 1
	
	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
default_faces=(
		reset '\e[m'
		default "$(:weight normal)"
		TODO "$(:background magenta)"
		NOTE "$(:background gray)"
		menu "$(:background yellow :foreground black)"
		menu-highlight '\e[4;30;43m'
		menu-enabled-face "$(:background yellow :foreground black)"
		menu-back '\e[4m\e[1m'
		menu-selected-face "$(:background light-yellow :foreground black :weight bold)"
		button "$(:foreground light-cyan)"
		link '\e[4;96m'
		link-highlight '\e[1;4;96m'
		title "$(:weight bold)"
		highlight "$(:weight bold :foreground light-red)"
		dim "$(:weight dim)"
		name "$(:foreground magenta)"
		#mode-line '\e[m'
		mode-line "$(:background yellow :foreground black)"
		hint "$(:foreground light-yellow)"
		hint-highlight '\e[4;93m'
		file-name "$(:weight bold)"
		line-number "$(:foreground gray)"
		line-number-empty "$(:weight dim :foreground gray)"
		line-number-current-line "$(:weight bold :foreground light-red)"
		tab-face "$(:weight dim :foreground gray)"
		region "$(:weight bold :background gray)"
		minibuffer-prompt "$(:weight normal)"
		# ansi colors
		ansi-color-black '\e[40m'
		ansi-color-blue '\e[44m'
		ansi-color-bold '\e[1m'
		ansi-color-bright-black '\e[100m'
		ansi-color-bright-blue '\e[104m'
		ansi-color-bright-cyan '\e[106m'
		ansi-color-bright-green '\e[102m'
		ansi-color-bright-magenta '\e[105m'
		ansi-color-bright-red '\e[101m'
		ansi-color-bright-white '\e[107m'
		ansi-color-bright-yellow '\e[103m'
		ansi-color-cyan '\e[46m'
		ansi-color-green '\e[42m'
		ansi-color-inverse '\e[7m'
		ansi-color-italic '\e[3m'
		ansi-color-magenta '\e[45m'
		ansi-color-red '\e[41m'
		ansi-color-underline '\e[4m'
		ansi-color-white '\e[47m'
		ansi-color-yellow '\e[43m'
		# common colors for format stuff
		black      '\e[30m' gray          '\e[90m'
		red        '\e[31m' light-red     '\e[91m'
		green      '\e[32m' light-green   '\e[92m'
		yellow     '\e[33m' light-yellow  '\e[93m'
		blue       '\e[34m' light-blue    '\e[94m'
		magenta    '\e[35m' light-magenta '\e[95m'
		cyan       '\e[36m' light-cyan    '\e[96m'
		light-gray '\e[37m' white         '\e[97m'
)
	load-theme default_faces
}

## syntaxy sugar sugary syntax
log_buffer+=('- LOADING BASH EXTENSIONS -')
function @ifs { IFS="$DEFIFS"; }
	
# Make bash not be bashy enough
function @doc {
	mapfile -t "description_${desc_count}"
	descriptions["function_${1}_description"]="description_${desc_count}"
	((desc_count++))
}

# reverse of defun :D
function nufed {
	((_addfragment==1)) && {
		@add '='
		_addfragment=0
	}
	IFS=
	local -a fn
	local deffn="function $_function"$'\n'
	mapfile fn <<<"$(declare -f '=')"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
	_isdone=0
	@ifs
	unset '='
}
	
	
@doc copy-function <<'+'
copies function \$1 to function \$2
advantage of copying instead of creating wrapper alias functions should be in theory performance(?)

Little test script:
    1() {
    	echo hi > /dev/null
    }
    echo 1
    time for e in {0..100000}; do
    	1
    done
    
    2() {
    	1
    }
    echo 2
    time for e in {0..100000}; do
    	2
    done
    
    3() {
    	2
    }
    echo 3
    time for e in {0..100000}; do
    	3
    done
    
    4() {
    	3
    }
    echo 4
    time for e in {0..100000}; do
    	4
    done

output:
    1
    
    real	0m1,636s
    user	0m1,081s
    sys	0m0,540s
    2
    
    real	0m1,986s
    user	0m1,453s
    sys	0m0,518s
    3
    
    real	0m2,380s
    user	0m1,873s
    sys	0m0,491s
    4
    
    real	0m2,768s
    user	0m2,154s
    sys	0m0,595s

It seems like there's small performace gain.
+
function copy-function {
	local -a fn
	local deffn="function $2"$'\n'
	mapfile fn <<<"$(declare -f "$1")"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
}

function defun {
	if [ -z "$1" ]; then
		nufed
	else
		((desc_count++))
		log_buffer+=("    DEFUN: $1")
		((_isdone)) && nufed
		_addfragment="${_pass_addfragment}"
		descriptions["function_${1}_description"]="description_${desc_count}"
		_function="$1"
		_isdone=1
		_last_add=add-doc
	fi
}

function ::
case "$_last_add" in
	add-menu) local-set-menu "$@";;
	set-alias) add-alias "$@";;
	set-highlight) add-highlight "$@";;
	global-set) global-set-key "$@";;
	set-options) define-option "$@";;
	add-doc) add-doc "$@";;
	add-mode) local-set-key "$@";;
	mode-options) local-set-mode-option "$@";;
	set-buffer) local-set-buffer-data "$@"
esac

function add-doc {
	local -n cdoc="description_${desc_count}"
	cdoc+=("${_indent}$*")
}
function doc {
	((desc_count++))
	descriptions["function_${1}_description"]="description_${desc_count}"
	_function="$1"
	_last_add=add-doc
	_indent=''
	shift
	[ -n "$*" ] &&
		:: "$*"
}
copy-function doc @@

## :+ Add documentation indent
function :+ {
	_indent+="    "
	# "$*"
}
## :- Remove documentation indent
function :- {
	_indent="${_indent:0:${#_indent}-4}"
	# "$*"
}
# hell

## focus set magic # function
function focus {
	_last_add="$1"
}

## declare-new-buffer Create new text buffer
function declare-new-buffer {
	_last_add='set-buffer'
	((current_count++))
	set-buffer "bf_${current_count}"
	buffers_l+=("$current_buffer")
	last_line=1
	declare -Ag "${current_buffer}_bf_d"
	bf_d=(
		# some sane default values
		[line]=0
		[base]=1
		[column]=0
		[modified]=0
	)
}

## local-set-buffer-data
# set bf_d[] array of currently \"focused\" buffer
function local-set-buffer-data {
	while [ -n "$2" ]; do
		bf_d["$1"]="$2"
		shift 2
	done
}

## [auto] Checks bf_d[] array and set\'s needed missing values automatically
function [auto] {
	[ -z "${bf_d[loc-x]}" ] && bf_d[loc-x]=1
	[ -z "${bf_d[loc-y]}" ] && bf_d[loc-y]=1
	[ -z "${bf_d[size-x]}" ] && bf_d[size-x]=$COLUMNS
	[ -z "${bf_d[size-y]}" ] && bf_d[size-y]=$((LINES - 1))
	[ -z "${bf_d[syntax]}" ] && set-syntax 
}

## defun-fragment Same as defun but includes fragments for the function
function defun-fragment {
	_pass_addfragment=1
	defun "$@"
}

# fragments act basically like macros but with cooler name
# see redraw-buffer function for example usage
## fragment Creates a function-insertable macro
function fragment {
	log_buffer+=("        FRAGMENT: $1")
	declare -ag "_fragment_$1"
	mapfile "_fragment_$1"
}
	
## @add Adds fragment to a function
function @add {
	local -a _add_fn
	local -a _add_nfn
	local -i _add_f
	local -i _add_hf
	local _add_nfnline
	mapfile _add_fn < <(declare -f -- "$1")
	IFS=' '
	for _add_l in "${!_add_fn[@]}"; {
		_add_f=0
		_add_hf=0
		_add_nfnline=
		for _add_w in ${_add_fn[_add_l]}; {
			if [ "$_add_w" = '@' ]; then
				_add_f=1
			elif ((_add_f)); then
				_add_f=0
				_add_hf=1
				local -n _add_fragment="_fragment_${_add_w//[^[:alnum:]]/}"
				for _add_l1 in "${!_add_fragment[@]}"; {
					_add_nfnline+=" ${_add_fragment[_add_l1]}"
				}
			else
				_add_nfnline+=" $_add_w"
			fi
		}
		((_add_hf)) || _add_nfn+="${_add_fn[_add_l]}"
		((_add_hf)) && _add_nfn+="$_add_nfnline"
	}
	eval "${_add_nfn[*]}"
}

## @def Defines a function template
function @def {
	local -n _tpl="_template_$1"
	local _fn
	local -i _n=0
	shift
	for _w in $_tpl; {
		case "$_w" in
			'@var')
				_n=1;;
			*)
				((_n)) && {
					_n=0
					_fn+="${!_w} "
					continue
				}
				_fn+="$_w "
		esac
	}
	eval "$_fn"
}

## _ Variable refernce helper
function _ {
	# this function is here to simplify stuff as writing overlong variables indexed by overloong variable index...
	# ...is quite tiring <3
	[ -z "$1" ] && {
		for n in "${refalias[@]}"; do
			unset "$n"
		done
		unset refalias
		return
	}
	declare -gn "$1"="$2"
	refalias+=("$1")
}

## __ Swap variable references
function __ {
	# swap two references
	local -n _swap_1="$1"
	local _swap_copy_1="${!_swap_1}"
	local -n _swap_2="$2"
	local _swap_copy_2="${!_swap_2}"
	declare -gn "$1"="${_swap_copy_2}"
	declare -gn "$2"="${_swap_copy_1}"
}

## @fn Shorthand for one line functions
function @fn {
	[ -z "$*" ] && exit 1 # error if empty
	local name="$1"
	shift
	eval "function $name { $@; }"
}

## copy-array
# A univeral function to copy both normal and associative arrays
function copy-array {
	local -n source="$1"
	local -n target="$2"
	target=()
	for idx in "${!source[@]}"; {
		target[idx]="${source[idx]}"
	}
}

## append-array
# Append array \$1 to \$2  
function append-array {
	local -n source="$1"
	local -n target="$2"
	for idx in "${!source[@]}"; {
		target+=("${source[idx]}")
	}
}

## setface Convert colors to escape codes
# '$1' can be either one of colors:
:+     black
#     red
#     green
#     yellow
#     blue
#     magenta
#     cyan
#     ligth-gray
#     gray
#     light-red
#     light-green
#     light-yellow
#     light-blue
#     light-magenta
#     light-cyan
#     white
:- 'or hex. color (like "#bb2040")'
# 'or indexed 256 color with "c" as prefix (like c127)'
# 'for background color $mode has to be 48 and for foreground 38'
::
# If \$TERM \(current "$TERM"\) is \'linux\' \& option tty-linuxfb is 1 try to use true color even for tty
# Instead of normal '\e[$mode;r;g;bm' is used '\e]P$~1mode$Hexcode\e[$~2modem'
:+     '$mode 38 → $~1mode 2 & $~2mode 32'
#     '$mode 48 → $~1mode 1 & $~2mode 41'
:- Note that the linuxfb colors are very experimental and suffer from cursor implicitly overwriting them on movenment
function setface {
	[ -z "$1" ] && return
	case "$1" in
		black)      [ "$mode" = '38' ] && printf '\\e[30m' || printf '\\e[40m';;
		red)        [ "$mode" = '38' ] && printf '\\e[31m' || printf '\\e[41m';;
		green)      [ "$mode" = '38' ] && printf '\\e[32m' || printf '\\e[42m';;
		yellow)     [ "$mode" = '38' ] && printf '\\e[33m' || printf '\\e[43m';;
		blue)       [ "$mode" = '38' ] && printf '\\e[34m' || printf '\\e[44m';;
		magenta)    [ "$mode" = '38' ] && printf '\\e[35m' || printf '\\e[45m';;
		cyan)       [ "$mode" = '38' ] && printf '\\e[36m' || printf '\\e[46m';;
		light-gray) [ "$mode" = '38' ] && printf '\\e[37m' || printf '\\e[47m';;

		gray)          [ "$mode" = '38' ] && printf '\\e[90m' || printf '\\e[100m';;
		light-red)     [ "$mode" = '38' ] && printf '\\e[91m' || printf '\\e[101m';;
		light-green)   [ "$mode" = '38' ] && printf '\\e[92m' || printf '\\e[102m';;
		light-yellow)  [ "$mode" = '38' ] && printf '\\e[93m' || printf '\\e[103m';;
		light-blue)    [ "$mode" = '38' ] && printf '\\e[94m' || printf '\\e[104m';;
		light-magenta) [ "$mode" = '38' ] && printf '\\e[95m' || printf '\\e[105m';;
		light-cyan)    [ "$mode" = '38' ] && printf '\\e[96m' || printf '\\e[106m';;
		white)         [ "$mode" = '38' ] && printf '\\e[97m' || printf '\\e[107m';;
		*) case "${1::1}" in
			   '#')
				   if [ "$TERM" = 'linux' ] && ((options[tty-linuxfb])); then # Hack for linux framebuffer tty
					   case "$mode" in
						   38) printf '\\e]P2%s\\e[32m' "${1:1:6}" ;;
						   48) printf '\\e]P1%s\\e[41m' "${1:1:6}"
					   esac
				   else
					   local r="${1:1:2}"
					   local g="${1:3:2}"
					   local b="${1:5:2}"
					   printf '\\e[%d;2;%d;%d;%dm' "${mode}" $((16#$r)) $((16#$g)) $((16#$b))
				   fi;;
			   'c')
				   printf '\\e[%d;5;%dm' "${mode}" "${1:1}"
		   esac
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :foreground
# Set foreground color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :foreground { mode=38; setface "$@"; }

## :background
# Set background color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :background { mode=48; setface "$@"; }

## :mode Sets text mode:
# '	inverse - inverses background and foreground'
function :mode {
	case "$1" in
		inverse) printf '\\e[7m';;
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## :weight Sets thickness of text:
:+     bold
#     dim
#     normal
function :weight {
	case "$1" in
		bold) printf '\\e[1m';;
		dim) printf '\\e[2m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :slant Sets slant of text:
:+     italic
#     normal
function :slant {
	case "$1" in
		italic) printf '\\e[3m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## kbd Converts Emacs like key notation into hex.
function kbd {
	local -i i=0
	local out
	local in
	local -i ch=1
	# Surely there is better solution...
	case "$1" in
		C-a) printf '1 0' ;; C-b) printf '2 0' ;;
		C-c) printf '3 0' ;; C-d) printf '4 0' ;;
		C-e) printf '5 0' ;; C-f) printf '6 0' ;;
		C-g) printf '7 0' ;; C-h) printf '8 0' ;;
		C-i) printf '9 0' ;; C-j) printf 'a 0' ;;
		C-k) printf 'b 0' ;; C-l) printf 'c 0' ;;
		C-m) printf 'd 0' ;; C-n) printf 'e 0' ;;
		C-o) printf 'f 0' ;; C-p) printf '10 0';;
		C-q) printf '11 0';; C-r) printf '12 0';;
		C-s) printf '13 0';; C-t) printf '14 0';;
		C-u) printf '15 0';; C-v) printf '16 0';;
		C-w) printf '17 0';; C-x) printf '18 0';;
		C-y) printf '19 0';; C-z) printf '1a 0';;
		*)  ch=0
			case "${1:0:2}" in
				M-) in="${1:2:1}";;
				*) in="$1"
			esac
	esac
	((ch)) && return
	echo "$in" | {
		while read -rsn1; do
			out+="$(printf "%x\n" "'${in:$i}") "
			((i++))
		done
	}
	out=${out::-1}
	printf '%s' "${out}"
}

## define-key defines keybinding
:+     '$1' can be either:
#     '[function-key]'
#     '[arrow-key]'
#     '[prior | next]'
#     'RET'
#     'DEL'
#     '[delechar]'
#     'hex code ending with 0'
function define-key {
	local -n keys="keys_$1"
	case "$2" in
		#function keys
		'[f1]') keys[1b 4f 50 0]="$3";;
		'[f2]') keys[1b 4f 51 0]="$3";;
		'[f3]') keys[1b 4f 52 0]="$3";;
		'[f4]') keys[1b 4f 53 0]="$3";;
		'[f5]')  keys[1b 5b 31 35 7e 0]="$3";;
		'[f6]')  keys[1b 5b 31 37 7e 0]="$3";;
		'[f7]')  keys[1b 5b 31 38 7e 0]="$3";;
		'[f8]')  keys[1b 5b 32 39 7e 0]="$3";;
		'[f9]')  keys[1b 5b 32 30 7e 0]="$3";;
		'[f10]') keys[1b 5b 32 31 7e 0]="$3";;
		'[f11]') keys[1b 5b 32 33 7e 0]="$3";;
		'[f12]') keys[1b 5b 32 34 7e 0]="$3";;
		#arrow keys
		'[left]')  keys[1b 5b 44 0]="$3";;
		'[up]')    keys[1b 5b 41 0]="$3";;
		'[right]') keys[1b 5b 43 0]="$3";;
		'[down]')  keys[1b 5b 42 0]="$3";;
		#pg up & down
		'[prior]') keys[1b 5b 36 7e 0]="$3";;
		'[next]')  keys[1b 5b 35 7e 0]="$3";;
		#return
		'RET') keys[a 0]="$3";;
		#backspace & delete
		'DEL') keys[7f 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		'ESC') keys[1b 0 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		*) keys["$2"]="$3"
	esac
}

## local-set-key
# Sets keybinding of lastly defined mode
# See define-key for details
@fn local-set-key 'define-key "$_last_keys" "$@"'

## global-set-key
# Sets keybinding of global mode
# See define-key for details
@fn global-set-key 'define-key global "$@"'

## define-mode-option
# Sets option of mode '$1'
function define-mode-option {
	local -n ko="key_options_$1"
	ko["$2"]="$3"
}

## local-set-mode-option See define-mode-option
@fn local-set-mode-option 'define-mode-option "$_last_keys" "$@"'

## mode-options Brings mode-options of lastly defined mode into \"focus\"
@fn mode-options '_last_add="mode-options"'


## add-alias Adds alias '$1' of command '$2...' to M-x
function add-alias {
	local name="$1"
	shift
	alias["$name"]="$@"
}

## set-alias Brings into \"focus\" alias setting
@fn set-alias '_last_add=set-alias'

## add-highlight Sets highlighting mode '$1' for file types '$2...'
function add-highlight {
	local name="$1"
	shift
	for i in "$@"; {
		highlight["$i"]="$name"
	}
}

## set-alias Brings into \"focus\" highlight setting
@fn set-highlight '_last_add=set-highlight'

## clear-screen clears screen
@fn clear-screen "printf '\033c'"

## add-mode
# Adds keybing mode
function add-mode {
	log_buffer+=("        ADD MODE $1")
	_last_keys="$1"
	_last_add='add-mode'
	modes+=("keys_$1")
	declare -Ag "keys_$1"
	declare -Ag "key_options_$1"
}

## add-menu
# Adds menu
function add-menu {
	# create new menu function & array
	log_buffer+=("        ADD MENU $1")
	eval "function menu-${1} { menu $1; }"
	declare -ag "menu_${1}_0"
	declare -ag "menu_${1}_1"
	_last_menu="$1"
	_last_add='add-menu'
}

## local-set-menu Sets \"focused\" menu item
@fn local-set-menu 'define-menu "$_last_menu" "$1" "$2"'

## global-set Brings into \"focus\" global mode
@fn global-set '_last_add=global-set'

## define-option Defines options[] buffer
@fn define-option 'options["$1"]="$2"'

## set-options Brings into \"focus\" options setting
@fn set-options '_last_add=set-options'

## define-menu
# Defines item in menu '$1' with name '$2' with command '$3'
# '    If command is "menu-top_menu" face menu-back is used.'
function define-menu {
	local -n menu_0="menu_${1}_0"
	local -n menu_1="menu_${1}_1"
	local item_0
	case "$3" in
		'menu-top_menu') item_0="$(printf '%b' "${faces[menu-back]}")$2";;
		*) item_0="$2"
	esac
	menu_0+=("$item_0")
	menu_1+=("$3")
}

## load-theme Loads theme from array
function load-theme {
	local -i t=0
	local k
	local -n theme="$1"
	for i in "${theme[@]}"; {
		((t==0)) && {
			k="$i"
			t=1
		} || {
			faces["$k"]="$i"
			faces_raw["$k"]="$(printf '%b' "$i")"
			t=0
		}
	}
	((t)) && errno=1 die
	# aliases for nicer formating
	faces+=(
		[bl]="${faces[black]}"
		[dr]="${faces[red]}"
		[dg]="${faces[green]}"
		[dy]="${faces[yellow]}"
		[db]="${faces[blue]}"
		[dm]="${faces[magenta]}"
		[dc]="${faces[cyan]}"
		[dw]="${faces[light-gray]}"
		[gr]="${faces[gray]}"
		[lr]="${faces[light-red]}"
		[lg]="${faces[light-green]}"
		[ly]="${faces[light-yellow]}"
		[lb]="${faces[light-blue]}"
		[lm]="${faces[light-magenta]}"
		[lc]="${faces[light-cyan]}"
		[lw]="${faces[light-white]}"
	)
	faces_raw+=(
		[bl]="${faces_raw[black]}"
		[dr]="${faces_raw[red]}"
		[dg]="${faces_raw[green]}"
		[dy]="${faces_raw[yellow]}"
		[db]="${faces_raw[blue]}"
		[dm]="${faces_raw[magenta]}"
		[dc]="${faces_raw[cyan]}"
		[dw]="${faces_raw[light-gray]}"
		[gr]="${faces_raw[gray]}"
		[lr]="${faces_raw[light-red]}"
		[lg]="${faces_raw[light-green]}"
		[ly]="${faces_raw[light-yellow]}"
		[lb]="${faces_raw[light-blue]}"
		[lm]="${faces_raw[light-magenta]}"
		[lc]="${faces_raw[light-cyan]}"
		[lw]="${faces_raw[light-white]}"
	)
}

## extension Set properites of extension
function extension {
	log_buffer+=("- LOADING EXTENSION $1 -")
	extensions+=("$1")
	declare -Ag "${1}_ext_d"
	declare -ng ext_d="${1}_ext_d"
}
## version: Set version of extension
function version: {
	ext_d[version]="$1"
}

log_buffer+=('- LOADING BASH EXTENSIONS DONE -')

## rest of this garbageware

## refresh Refreshes buffer
# 'clears screen, reset syntax, redraws'
# 'See <a> doc-goto clear-screen : <f> link clear-screen </f> </a> for more info.'
function refresh {
	clear-screen
	bf_s=''
	
	message="reloaded..."
	redraw
}

## switch-mode
# Change current mode of buffer into '$1'
function switch-mode {
	bckmode="${bf_d[mode]}"
	bf_d[mode]="$1"
	redraw-statusline
}

## mode-back
# Restores previous mode
function mode-back {
	bf_d[mode]="$bckmode"
	unset bckmode
	redraw-statusline
}

## read-command
# Works like normal "'read'" but for bottom commanline
function read-command {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	read -re -p "$1" -i "$3" "$2" || return 1
}

## base-name
# Basically equivalent to the "'basename'" coreutil		
function base-name
	for file in "$@"; {
		file="${file%/}"
		printf '%s\n' "${file##*/}"
	}

### TODO: make this make sense

## make-render Creates syntax highlighting for currently visible lines
function make-render {
	make-render-area "${bf_d[base]}" $((bf_d[base] + bf_d[size-y] + bf_d[loc-y]))
}

## make-render-area
# Creates syntax highlighting for lines from '$1' to '$2'
function make-render-area {
    local -i line="$1"
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	for ((l=syntaxline;l<${2};l++)); do
		((l > $2)) && break
		local -n linearray="${current_buffer}_syntax${syntaxline}"
		linearray=()
		bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
		((syntaxline++))
		line="$l"
		make-render-line-loop
	done
	IFS="$bckeIFS"
}
	
## make-render-line
# Syntax highlights single line '$1'
# Defaults to currently selected line if no argument is passed
function make-render-line {
	local -i line=${1:-bf_d[line]}
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	make-render-line-loop
	IFS="$bckeIFS"
}



## make-render-line-loop
# Backend for make-render-area \& make-render-line
# Also creates bf_e charmap for movenment
:+     "Tab is 't'"
#     "Space is 's'"
#     "Any unmaped char is '0'"
function make-render-line-loop {
	local -i comment=0
	local -i skip_next_space=0
	local word=''
	bf_e[line]=''

	for _link in ${bf_c[line]}; do
		unset "$_link"
	done
	unset bf_c[line]
		
	column=0
	while read -rsn1 char; do	
		case "$char" in
			' ')
				syntax-word
				word=''
				((skip_next_space==1)) && skip_next_space=0 && continue
				bf_e[line]+='s'
				face-no-expand "${facename:-default}" ' '
				((column++));;
			'	')
				syntax-word
				word=''
				local -i i
				for ((i = ${#options[tabchar]}; i > 0 ; i--)); do
					bf_e[line]+="${charmap[	]}"
				done
				face-no-expand tab-face "${options[tabchar]}"
				((column+=${#options[tabchar]}));;
			'')
				syntax-word
				word=''
				skip_next_space=0
				face-no-expand default ' '
				newline=1 # tell syntax functions that the previous char was newline # used for format thing
				return;;
			*)
				word+="${char}"
		esac
	done  <<< "${buffer[line]}"
}

## syntax-word
# Decides what a word should highlighted as:
:+     'If todonote option is enabled, highlight "NOTE:" & "TODO:"'
#     'If the word is supposed to be comment highlight it as it'
#     'Else pass it to current syntax function'
function syntax-word {
	(("${options[todonote]}"==1)) && {
		case "$word" in
			'NOTE:') face NOTE "${word}"; return ;;
			'TODO:') face TODO "${word}"; return ;;
		esac
	}
	((comment)) && set-face font-lock-comment-face ||
		"${bf_d[syntax]}"
	((bf_d[syntax-exec])) || face "$syntax_face" "$word" # s_ex controls syntax extended
}

## face
# Add highlighted word to multidimensional nonsense "'bf_s'" arry
function face {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
	for ((iw=0; iw < ${#2}; iw++)); do
		bf_e[line]+='0'
	done
}

## face-no-expand
# Add highlighted word to multidimensional nonsense "'bf_s'" arry without adding anything to bf_e[] array
function face-no-expand {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
}

## set-face Sets face for syntax highlighting
@fn set-face 'syntax_face="$1"'

## size-full
# Sets size of buffer to be fullscreen
function size-full {
	bf_d+=(
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$((LINES - 1))
	)
}

## set-buffer
# Switch to buffer \$1 
function set-buffer {
	log info "switch to buffer [$1]"
	current_buffer="$1"
	declare -ng buffer="${current_buffer}_buffer"
	declare -ng bf_s="${current_buffer}_bf_s"
	declare -ng bf_e="${current_buffer}_bf_e"
	declare -ng bf_d="${current_buffer}_bf_d"
	declare -ng bf_c="${current_buffer}_bf_c"
}

## add-to-list
# Adds a buffer into currently active buffer list
function add-to-list {
	log info "added into buffer list: $current_buffer"
	buffers_l+=("$current_buffer")
}

## clear-buffer
# Empties buffer bf_s bf_e \& bf_d
function clear-buffer {
	buffer=()
	for l in "${bf_s[@]}"; {
		unset "$l"
	}
	bf_s=()
	bf_e=()
	for l in "${bf_c[@]}"; {
		unset "$l"
	}
	bf_c=()
}

## list-directory
# Basically like ls command
	# '    If' \$hidden is 1 also show hidden files 
	# '    If' \$hidden is 0 also show the special .. 
function list-directory {
	printf '..\n'
	((hidden==0)) || printf '%s\n' .*
	printf '%s\n' *
}

## current-time
# Basically like coreutil "'date'"
@fn current-time 'printf "%($1)T\\n"'

## log
# Adds message into log
# '    info -- everything *should* be well'
# '    warn -- something is wrong but it *should* not break entire Ebashs'
# '    error -- something is wrong and anything can break, but it *can* still run(?)'
# '    fatal -- something is mega wrong and only thing left to do is to die'
# Is disabled when log wasn\'t initialised, see init-log for info
function log {
	((log)) || return
	local type="$1"
	shift
	tooktime="$(( $(current-time '%s') - lasttime ))"
	bufferlog+=("<f> title [$type] </f> <f> font-lock-comment-face ${tooktime}s </f> <f> name [${FUNCNAME[1]}] </f> $*")
	lasttime="$(current-time '%s')"
}

## log-echo
# Adds message into log without any special formating	
function log-echo {
	((log)) || return
	bufferlog+=("<f> font-lock-comment-face > </f>    $*")
}

## debug
# +debug -- basically like set -x but reports stuff into log
## +log	
# Debug function to add logging to function it\'s called from
function +log {
	((log)) || return
	((options[log-functions])) && log '*' "${FUNCNAME[1]}"
	trap 'log bash $? $LINENO ${BASH_COMMAND}' ERR
}
## +debug
# Debug function to add extensive \(set -x like\) logging to function it\'s called from
function +debug {
	((log)) || return
	trap 'log DEBUG "${BASH_COMMAND}"' DEBUG
}

## goto Load array into buffer
function goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
	copy-array "$1" buffer
	redraw
}

@doc syntax-format <<'EOF'
Convert formated text into Ebashs buffer understandable format.

<f> title <u> Specifications </u> </f>

<[> name <f> <f> hint face_name text... </f> <[> name </f>
<-> Set <f> hint text </f> to face <f> hint face_name </f-> .

<[> name <h> <f> hint text... </f> <[> name </h>
<-> Make <f> hint text </f> into title.

<[> name <a> <f> hint command </f> <[> name : <f> hint text </f> <[> name </a>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> See <a> doc-goto link-enter : <f> link link-enter </f> </a> 

<[> name <link> <f> hint command </f> <[> name : <f> hint text </f> <[> name </link>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> <[> name <link> also automatically adds <f> link link </f> face to text.

<[> name <u> <f> hint text </f> <[> name </u>
<-> Make <f> hint text </f> <u> uppercase. </u>

<[> name <i> <f> hint number_of_spaces hint text </f-> ...\n...\n...\n... <[> name </i>
<i-tab> Indent lines by <f> hint number of spaces </f-> .

<[> name <i-tab>
<-> Indent by tab (default 4 spaces).
<-> Tab size is controlled via tab_format variable. </i>

<[> name <s> <f> hint number_of_spaces </f>
<-> Insert <f> hint number of spaces </f-> .

<[> name <tab>
<-> Insert tab.
<-> <[> name <-> is alias for <[> name <tab>.

<[> name <v> <f> hint variable_name </f> <[> name </v>
<-> Insert contents of <f> hint variable </f> into text at formating time.

<[> name <\> <f> hint text </f>
<-> Escape <f> hint text </f>

<[> name <[> <f> hint face_name text </f>
<-> Escape <f> hint text </f> with <f> hint face </f-> .


Some of these keywords also include versions to glue together with other words.
For example:
<-> text <[> name <-f> <f> name face </f> color! <[> name </f-> text
Will turn into text <-f> lr c <-f> ly o <-f> lg l <-f> lc o <-f> lb r <-f> lm ! </f> </f> </f> </f> </f> </f-> text.
EOF
function syntax-format {
	((skip_word==1)) && {
		skip_next_space=1
		[ "$word" = '-->' ] && skip_word=0
		return
	}
	[ "$word" = '<!--' ] && {
		skip_next_space=1
		skip_word=1
		return
	}
	((newline==1)) && {
		ichar="${indent_spaces}"
	}
	((newline==0)) && {
		ichar=
	}

	((escape==2)) && {
		escape=1
		facename="$word"
		skip_next_space=1
		return
	}
	((escape==1)) && {
		escape=0
		face "$facename" "${ichar}$word"
		return
	}
	[ "$word" = '<\>' ] && {
		escape=1
		skip_next_space=1
		facename='unknown'
		return
	}
	[ "$word" = '<[>' ] && {
		escape=2
		skip_next_space=1
		return
	}
	
	((variable==1)) && {
		variable=0
		word="${!word}"
	}
	[ "$word" = '<v>' ] && {
		variable=1
		varname=
		skip_next_space=1
		return
	}

	[ "$word" = '</u>' ] && {
		upper=0
		skip_next_space=1
		return
	}
	[ "$word" = '<u>' ] && {
		upper=1
		skip_next_space=1
		return
	}
	[ "$word" = '</f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '</f->' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		skip_next_space=1
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	((facedef==1)) && {
		skip_next_space=1
		facedef=0
		facename="$word"
		return
	}
	[ "$word" = '<f>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	[ "$word" = '<-f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	
	[ "$word" = '</h>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		upper=0
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<h>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=title
		upper=1
		return
	}
	
	((sethighlight==2)) && {
		sethighlight=1
		skip_next_space=1
		tmp_sex="$word"
		return
	}
	((sethighlight==1)) && {
		sethighlight=0
		skip_next_space=1
		bf_d[syntax-exec]="$tmp_sex"
		bf_d[syntax]="syntax-$word"
		return
	}
	[ "$word" = '<change-syntax>' ] && {
		skip_next_space=1
		sethighlight=2
		return
	}
	((space_next==1)) && {
		space_next=0
		skip_next_space=1
		for ((if=0; if< word; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '<s>' ] && {
		space_next=1
		skip_next_space=1
		return
	}
	[ "$word" = '<tab>' ] || [ "$word" = '<->' ] && {
		skip_next_space=1
		for ((if=0; if< format_tab; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '</i>' ] && {
		indent_spaces=
		return
	}
	((indent==1)) && {
		indent=0
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< word; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	[ "$word" = '<i>' ] && {
		indent=1
		skip_next_space=1
		return
	}
	[ "$word" = '<i-tab>' ] && {
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< format_tab; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	((link==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				link=1
			))
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</a>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		return
	}
	[ "$word" = '<a>' ] && {
		((
			link=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	((facelink==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				facelink=1
			))
			facename='link'
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</link>' ] && {
		((lc++))
		((column--))
		facelink=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<link>' ] && {
		((
			facelink=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	
	((object==1)) && {
		skip_next_space=1
		[ "$word" = 'text:' ] && {
			object=0
			set_obj=0
			return
		}
		[ "$word" = 'select:' ] && { set_obj=1; obj_select=; return; }
		[ "$word" = 'id:' ] && { set_obj=2; obj_id=; return; }
		[ "$word" = 'left:' ] && { set_obj=3; obj_left=; return; }
		[ "$word" = 'up:' ] && { set_obj=4; obj_up=; return; }
		[ "$word" = 'right:' ] && { set_obj=5; obj_right=; return; }
		[ "$word" = 'down:' ] && { set_obj=6; obj_down=; return; }

		((set_obj==1)) && obj_select+="$word "
		((set_obj==2)) && obj_id+="$word "
		((set_obj==3)) && obj_left+="$word "
		((set_obj==4)) && obj_up+="$word "
		((set_obj==5)) && obj_right+="$word "
		((set_obj==6)) && obj_down+="$word "
		return
	}
	[ "$word" = '</o>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$obj_select"
			[id]="$obj_id"
			[left]="$obj_left"
			[up]="$obj_up"
			[right]="$obj_right"
			[down]="$obj_down"
		)
		return
	}
	[ "$word" = '<o>' ] && {
		((
			object=1,
			lsx=column,
			skip_next_space=1
		))
		obj_id=
		obj_text=
		obj_select='true'
		obj_left='backward-char'
		obj_up='previous-line'
		obj_right='forward-char'
		obj_down='next-line'
		set_obj=0
		return
	}
	
	((newline==1)) && newline=0
	((column+=${#ichar} + ${#word}))
	((upper==1)) && {
		word="${word^^}"
	}
	face "${facename:-unknown}" "${ichar}$word"
}

@doc link-enter <<'EOF'
Executes <f> name clickable area </f> of formated text to which current position
of cursor points.
Mostly used for <f> name hyperlinks </f-> .

Internally <f> name clickable area </f> is defined via bf_c 2d array. Each line contains
the <f> name clickable areas </f-> . Each of these is it's own associative array.
Each <f> name clickable area </f> contains:
<i-tab> <[> hint start - the first column of the area
<[> hint end   - the last column of the area
<[> hint exec  - what command should be executed when this function,
<-> <f> name link-enter </f> is ran. </i>
EOF
function link-enter {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		#echo "    $link" >> d
		#echo "${bf_c_line[start]}" >> d
		#echo "${bf_c_line[end]}" >> d
		#echo "${bf_c_line[exec]}" >> d
		
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				has=1
				${bf_c_line[exec]}
				return
			}
	}
	${bf_d[format-else]}
}

function format-left {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[left]:-backward-char}
				return
			}
	}
	backward-char
}
function format-up {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[up]:-previous-line}
				return
			}
	}
	previous-line
}
function format-right {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[right]:-forward-char}
				return
			}
	}
	forward-char
}
function format-down {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[down]:-next-line}
				return
			}
	}
	next-line
}

function obj {
	for y in "${!bf_c[@]}"; {
		for obj in ${bf_c[y]}; {
			local -n bf_c_line="$obj"
			[ "${bf_c_line[id]}" = "$1 " ] && {
				((bf_d[line]=y, bf_d[column]=bf_c_line[start]))
				redraw-cursor
			}
		}
	}
}
	
@fn is-function 'declare -F -- "$1" > /dev/null'

## Dumps current buffer into a file	
function dump-buffer {
	true >"$1" # Set the file to an empty text file
	for ln in "${buffer[@]}"; do # Write in the buffer to the file
		echo "$ln" >>"$1"
	done
}

## die
# Closes Ebashs with exit code \$errno, if errno is empty exit with 0
# If \$nocleanup is 1, do not restore the terminal to sane mode and do not cleanup 
# Else restore to sane mode 
function die {
	((nocleanup)) && exit "${errno:-0}"
	${on_die:-true}
	echo -e "\e[?1000;1006;1015l" #disable mouse tracking
	clear-screen # TODO fix the buffer switching
	printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
	exit "${errno:-0}" # Assume that we are exiting without an error
}

# Sets \$nocleanup to 1 and dies	
function abort {
	((nocleanup=1)) && die "$@"
}

fragment keepcolumn <<'+'
	[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
	(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
	(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
+

# Moves up \$1 lines, if \$ is empty move up 1 line
function move-previous-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] > 1)) && ((bf_d[line]--)) # As long as we can keep going up, go up
		((bf_d[line] < bf_d[base] + 1)) && {
			((bf_d[base]--)) # Push back the top if we need to
			move_base=1 # Send signal to redraw-cursor that the buffer was moved, thus needs to be redraw fully
			((bf_d[base] <= 0)) && bf_d[base]=1 # Don't push back if our base is at 1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

# Moves down \$1 lines, if \$ is empty move down 1 line
function move-next-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] < ${#buffer[@]}+1)) && ((bf_d[line]++)) # If we can go down, go down
		# Move window down if needed
		((bf_d[line] > bf_d[base] + bf_d[size-y] - 3 - bottomlines)) && {
			((bf_d[base]++))
			move_base=1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

function previous-line {
	move-previous-line "$@"
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function next-line {
	move-next-line "$@"
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function scroll-down {
	move-previous-line '$((bf_d[size-y] - 3))'
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function scroll-up {
	move-next-line '$((bf_d[size-y] - 3))'
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
	
@fn move-beginning-of-line 'bf_d[column]=0; redraw'
@fn move-end-of-line 'bf_d[column]="${#bf_e[${bf_d[line]}]}"; redraw'


function move-select {
	((bf_d[selection])) || {
		bf_d[selection_start_y]="${bf_d[line]}"
		bf_d[selection_start_x]="${bf_d[column]}"
		bf_d[selection]=1
	}
}

function select-forward {
	move-select
	forward-char
}
function select-backward {
	move-select
	backward-char
}
function select-next {
	move-select
	next-line
}
function select-previous {
	move-select
	previous-line
}

function forward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}+1:1}" in
			't') bf_d[column]=$(( bf_d[column]+${#options[tabchar]}));;
			*) ((bf_d[column]++));;
		esac
		((bf_d[column] > ${#bf_e[${bf_d[line]}]})) && {
			bf_d[column]=0
			next-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor-line
	fi
}

function backward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}-1:1}" in
			't') bf_d[column]=$(( bf_d[column]-${#options[tabchar]}));;
			*) ((bf_d[column]--));;
		esac
		((bf_d[column] < 0)) && ((bf_d[line]==1)) && {
			bf_d[line]=1
			bf_d[column]=0
		}
		((bf_d[column] < 0)) && {
			bf_d[column]="${#bf_e[${bf_d[line]}-1]}"
			previous-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor-line
	fi
}
	
## forward-word
# Moves forward to next word
function forward-word {
	((bf_d[column] == ${#bf_e[bf_d[line]]})) && {
		next-line
		move-beginning-of-line
	}
	while :; do
		((bf_d[column] < ${#bf_e[bf_d[line]]})) && ((bf_d[column]++)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}

## backward-word
# Moves backward to previous word
function backward-word {
	((bf_d[column] == 0)) && {
		previous-line
		move-end-of-line
	}
	while :; do
		((bf_d[column] > 0)) && ((bf_d[column]--)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}


@doc to-line <<'+'
Move cursor to line number $1 and move the line into middle of visible buffer area.
+
function to-line {
	bf_d[line]="$1"
	bf_d[base]=$((bf_d[line] - bf_d[size-y] / 2 ))
	redraw
}
			
# Handle clicking on top menu with mouse		
function menuline-mouse {
	local -n top_0="menu_${bf_d[menuline]}_0"
	local -n top_1="menu_${bf_d[menuline]}_1"
	#determine which item should be triggered
	[ -z "$1" ] && menuloc_x=0 || menuloc_x=$1
	local cx="${bf_d[loc-x]}"
	i=0
	for i in "${!top_0[@]}"; {
		la="${#top_0[i]}"
		((menuloc_x>cx)) && ((menuloc_x<(cx + la + 1))) && {
			${top_1[$i]}
			return
		}
		cx=$(( cx + la + 1 ))
	}
}
# Redraw popup menu
function redraw-menu {
	printf '\e[?25l' # hide cursor (again)
	printf '\e[%s;0H' $menuloc_y
	for i in "${!menu_0[@]}"; {
		if ((i == menuselection)); then
			printf "\e[%sC${faces[menu-selected-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"  
		else
	   		printf "\e[%sC${faces[menu-enabled-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"
		fi
	}
}


function menuup {
	((menuselection > 0)) && ((menuselection--));
	redraw-menu;
}
function menudown {
	((menuselection < ${#menu_0[@]} -1)) && ((menuselection++));
	redraw-menu;
}

# Execute selected item in menu
function menuselect
for i in "${!menu_1[@]}"; {
	((i == menuselection)) && "${menu_1[i]}"
}

# Closes a menu
function menuleave {
	ismenu=0
	bf_d[mode]="${modebackup}"
	redraw
}

# Opens a menu \$1	
function menu {
	declare -ng menu_0=menu_${1}_0
	declare -ng menu_1=menu_${1}_1
	((ismenu == 0 )) && modebackup="${bf_d[mode]}"
	ismenu=1
	declare -ig menuselection=0
	bf_d[mode]='menu'
	redraw
}

# deletes current buffer
function delete-buffer {
	local -a copy
	local i=0
	local index
	for b in "${buffers_l[@]}"
	do
		[[ "$b" != "$current_buffer"  ]] && copy+=("$b")
		[[ "$b" = "$current_buffer"  ]] && index="$i"
		((i++))
	done
	unset buffers_l
	copy-array copy buffers_l
	current_buffer="${buffers_l[index-1]}"
	redraw
}
						
# Draw multiline region
function selection-draw
if ((i == bf_d["${1}_y"])); then
	printf "${ln}%*s\e[%sG%b%s%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${linearray[*]:bf_d[basecolumn]:bf_d[${1}_x]}"\
		   "\e[m${faces[region]}"\
		   "${buffer[i]:bf_d[${1}_x]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
		   "${faces[default]}" "$nlchar"
elif ((i == bf_d["${2}_y"])); then
	printf "${ln}%*s\e[%sG%b%b%s%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${faces[region]}"\
		   "${buffer[i]:bf_d[basecolumn]:bf_d[${2}_x]}"\
		   "\e[m"\
		   "${linearray[*]:bf_d[${2}_x]:bf_d[size-x]}"\
		   "${faces[default]}" "$nlchar"
else
	printf "${ln}%*s\e[%sG%b%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${faces[region]}" "${buffer[i]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
		   "${faces[default]}" "$nlchar"
fi

# Handle changing size of terminal
function change-size-screen {
	bf_d[size-x]="$COLUMNS"
	bf_d[size-y]=$((LINES-1))
	redraw
}
	
## redraw
# Redraw screen
function redraw {
	[ -n "${bf_d[redraw]}" ] && {
		"${bf_d[redraw]}" "$@"
		return
	}
	printf '\e[?25l'

	# the first line should be always empty 
	unset buffer[0]
	
	# Handle changing size of buffer
	((bf_d[size-x]!=bcksize_x)) || ((bf_d[size-y]!=bcksize_y)) && {
		# Make the statusline full of dashes
		dashline=$(
			for ((i=0; i<bf_d[size-x]; i++)) {
				printf '-'
			}
		)
		bcksize_x=${bf_d[size-x]}
		bcksize_y=${bf_d[size-y]}
	}
		
	# Get length of line-number of lines
	bf_d[length]="${#buffer[@]}"
	((bf_d[length]==0)) &&((bf_d[length]++))
	
	((options[line-number-mode])) && {
		bf_d[number-length]=${#bf_d[length]}
		bf_d[number-space]=1
	} || ((bf_d[number-length]=0, bf_d[number-space]=0))
	
	# Update selection ends to current cursor
	((bf_d[selection]==1)) &&
		((bf_d[selection_end_y]=bf_d[line], bf_d[selection_end_x]=bf_d[column]))
	
	# Move the buffer horizontally if needed
	((bf_d[column] +3 < bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=0
	((bf_d[column] +3 > bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=$((bf_d[column] - (bf_d[size-x] + bf_d[loc-x] - bf_d[number-length] - 1) +3))

	# Draw top menuline
	(("${options[menu-line]}"==1)) && {
		"${bf_d[menuline-function]:-redraw-menuline}"
	} || printf "\e[%s;%sH" "${bf_d[loc-y]}" "${bf_d[loc-x]}"

	# IFS has to be empty in order to bufferarray multiarray be printed as words instead of chars
	IFS=''

	# Handle line number displaying
	# the resulting line has to be printed in one go to prevent flicker
	# space stores if the position of actuall text should be offset by +1
	# ln stores printf print line
	# args stores printf arguments
	local -i space
	local ln
	local -a lnargs
	
	# Iterate over shown lines
	local -i max=$((bf_d[size-y] - (toplines + bottomlines) + 1))
	for ((i = bf_d[base]; i - bf_d[base] < max; i++)); do
	# if the line is last, do not add newline

		ln="\e[%dG"
		lnargs=(
			"${bf_d[loc-x]}"
		)
		if ((options[line-number-mode])); then
			space=1
			ln="\e[%dG%b%*s"
			lnargs=(
				"${bf_d[loc-x]}"
				"${faces[line-number]}"
				"${bf_d[number-length]}"
				"$i"
			)
			((i == bf_d[line])) && lnargs[1]="${faces[line-number-current-line]}"
		fi
		
		((i - bf_d[base] > max - 2)) && nlchar='' || nlchar='\n'

		((i > ${#buffer[@]})) &&
			printf '\e[%sG%b%*s%s%b%*s%b'\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number-empty]}"\
				   $((bf_d[number-length]/2)) ''\
				   "${options[empty-line-char]}"\
				   "${faces[default]}"\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   "$nlchar" &&
			continue
		
		# to improve speed syntaxing has to be "lazy" -- having to be heavily cached as ram is far less expensive to waste
		[ -z "${bf_s[base+i]}" ] && {
			make-render-line $((base + i))
		}
		local -n linearray="${bf_s[i]}"
		
		# draw the selection area
		((bf_d[selection])) && {
			((i == bf_d[selection_start_y])) &&
				((bf_d[selection_start_y] == bf_d[selection_end_y])) && {
					((bf_d[selection_start_x] <= bf_d[selection_end_x])) && {
						local -n sx=bf_d[selection_start_x]
						local -n ex=bf_d[selection_end_x]
					} || {
						local -n sx=bf_d[selection_end_x]
						local -n ex=bf_d[selection_start_x]
					}
					printf "${ln}%*s\e[%sG%b%s%b%s%b%s%b"\
						   ${lnargs[@]}\
						   $((bf_d[size-x] - bf_d[number-length]))\
						   ''\
						   $((bf_d[loc-x] + bf_d[number-length] + space))\
						   "${faces[default]}"\
						   "${linearray[*]:bf_d[basecolumn]:sx}"\
						   "\e[m${faces[region]}"\
						   "${buffer[i]:sx:ex-sx}"\
						   "\e[m"\
						   "${linearray[*]:ex:bf_d[size-x]}"\
						   "$nlchar"
					continue
				}
			((i >= bf_d[selection_start_y])) && ((i <= bf_d[selection_end_y])) && {
				selection-draw selection_start selection_end
				continue
			}
			((i <= bf_d[selection_start_y])) && ((i >= bf_d[selection_end_y])) && {
				selection-draw selection_end selection_start
				continue
			}
		}
		# due to escape codes present in bf_s,
		# the bf_s has to be multidimensional nonsense for perfomance reasons
		printf "${ln}%*s\e[%sG%b%s%b"\
			   ${lnargs[@]}\
			   $((bf_d[size-x] - bf_d[number-length]))\
			   ''\
			   $((bf_d[loc-x] + bf_d[number-length] + space))\
			   "${faces[default]}"\
			   "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"\
			   "$nlchar"
	done
	redraw-statusline
	redraw-commandline
	((no_cursor)) || redraw-cursor		
	@ifs		
	# redraw menu if open
	[ "${bf_d[mode]}" = 'menu' ] && redraw-menu
}

## redraw-menuline Redraws top menu line
function redraw-menuline {
	local -n top_0="menu_${bf_d[menuline]}_0"
	printf "\e[0m\e[%s;%sH${faces[menu]}\e[?25l%*s\r%s"\
		   "${bf_d[loc-y]}"\
		   "${bf_d[loc-x]}"\
		   "${bf_d[size-x]}"\
		   "${bf_d[info]}"
	printf '\e[%sG%s\e[0m\n' "${bf_d[loc-x]}" "${top_0[*]}"
}

# Draw cursor on the line
function redraw-cursor-line {
	((options[full-redraw]==0)) && {
		# redraw if buffer needs to be moved horizontally
		((bf_d[column] > bf_d[size-x] - bf_d[number-lenght] - space)) && {
			redraw
			return
		}
		((bf_d[basecolumn]==0)) || {
			redraw
			return
		}
		printf '\e[%sG\e[?25h'\
			   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space])) ||
			redraw
	}
}
	
# Draw cursor and if move_base is 1 redraw
function redraw-cursor {
	((options[full-redraw])) && {
		no_cursor=1
		redraw
		no_cursor=0
	}
	((move_base)) && {
		move_base=0
		redraw
		return
	}
	local -i y=$((bf_d[line] + options[menu-line] - bf_d[base] + bf_d[loc-y]))
	((options[line-number-mode])) && {
		printf '\e[%s;%sH%b%*s\e[m'\
			   $((last_line + options[menu-line] - bf_d[base] + bf_d[loc-y]))\
			   "${bf_d[loc-x]}"\
			   "${faces[line-number]}"\
			   ${bf_d[number-length]}\
			   $last_line
		printf '\e[%s;%sH%b%*s\e[m'\
			   $y\
			   "${bf_d[loc-x]}"\
			   "${faces[line-number-current-line]}"\
			   ${bf_d[number-length]}\
			   ${bf_d[line]}
	}
	printf '\e[%s;%sH\e[?25h'\
		   $y\
		   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space]))
	last_line=${bf_d[line]}
}

# Draw bottom mode/status line
function redraw-statusline {
	((options[mode-line])) &&
		printf "\e[%s;%sH\e[%sG%b%s\e[%sG%s %b%s\e[m%b %d%% (%d,%d) (%s[%s]) (screen: %s) \e[m" \
			   $((bf_d[size-y] - 1 + bf_d[loc-y]))\
			   $((bf_d[size-x] + bf_d[loc-x]))\
			   "${bf_d[loc-x]}"\
			   "${faces[mode-line]}"\
			   "$dashline"\
			   "${bf_d[loc-x]}" \
			   "${bf_d[mode]}"\
			   "${faces[file-name]}"\
			   "$(base-name "${bf_d[file]}")"\
			   "${faces[mode-line]}"\
			   $((100 * bf_d[line] / bf_d[length]))\
			   "${bf_d[line]}"\
			   "${bf_d[column]}"\
			   "${highlight[${bf_d[filetype]}]}"\
			   "${bf_d[filetype]}"\
			   "$current_buffer"
}

# Draw bottomest command line message echo area
function redraw-commandline {
	# clear message if it has been printed before already
	((options[keep-message]==0)) && 
		((clrmsg)) && {
			message=
			clrmsg=0
		} || clrmsg=1
	if ((options[command-line])); then
		printf "\e[%s;%sH\n${faces[minibuffer-prompt]}%*s\r%s\e[m" \
			   $((LINES-1)) 1 $((COLUMNS)) ' ' "$message"
	else
		[ -n "$message" ] &&
			printf "\e[%s;%sH%s" \
				   $((LINES)) 1 "$message"
	fi
}

## handle-mouse
# Handle mouse click
function handle-mouse {
	local -i x y
	#parse mouse stuff somewhatish weirdly
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
	((skipnext==1)) && skipnext=0 && return
	((skipnext==0)) && [ "${k_hex[*]:0:2}" = '1b 5b' ] && {
		mapfile -t -d '' inputarray <<< "${1}"
		inputarray[-1]="${inputarray[-1]%?}"
		[ -z "${inputarray[2]}" ] && skipnext=1
		mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
		inputarray[-1]="${inputarray[-1]%?}"	
		mousemode="${inputarray[0]}"
		x="${inputarray[1]}"
		y="${inputarray[2]::-1}"
		#limitations of movenment
		#TODO:
		[ $y = "${bf_d[loc-y]}" ] && menuline-mouse $x && return #handle menuline
		((x < (bf_d[number-length] + bf_d[loc-x] + 2))) && {
			if [ "$mousemode" = '[<0' ]; then
				bf_d[line]=$(( bf_d[base] + ( (y - bf_d[loc-y]) - toplines) ))
				redraw
			elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
				clear-screen
				echo 'Enter the index: '
				read -re line
				redraw
			fi
			return
		}
		bf_d[line]=$(( bf_d[base] + ( y - bf_d[loc-y] - 1) ))
		bf_d[column]=$(( x - (bf_d[loc-x] + bf_d[number-length] + 1) ))
		((bf_d[line] > ${#bf_e[@]})) &&
			bf_d[line]=${#bf_e[@]}
		((bf_d[column] > ${#bf_e[bf_d[line]]})) &&
			bf_d[column]=${#bf_e[bf_d[line]]}
		redraw
	}
}

## insert-word
# Insert \$1 to buffer
function insert-word {
	((options[save-states])) && save-state
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
	buffer[bf_d[line]]="${buffer[${bf_d[line]}]:0:${rlr}}$1${buffer[${bf_d[line]}]:${rlr}}"
	#add at cursor position - amount of tabs * tab size
	make-render-line
	forward-char "${#1}"
	bf_d[selection]=0
	redraw
	bf_d[modified]=1
}

## input-key Handles input
# Either \$1 raw character input or k_hex array containing hex values of characters is used
function input-key {
	#arg $1 is the pressed key in normal text form
	#k_hex is pressed key in hex array ending with 0
		
	local -i mode_contains=0
	local -n modekeys="keys_${bf_d[mode]}"\
	         key_options="key_options_${bf_d[mode]}"

	# global keys
	((key_options[disable-global])) ||
		for str in "${!keys_global[@]}"
		{
			[ "$str" = "${k_hex[*]}" ] && {
				"${keys_global[$str]}"
				return
			}
		}

	# Execute the 'always' key option
	((${#key_options[@]})) &&
		[ -n "${key_options[always]}" ] && "${key_options[always]}"

	# Loop over current mode keybindings to match current keypress
	for str in "${!modekeys[@]}"
	{
		[ "$str" = "${k_hex[*]}" ] && {
			"${modekeys[$str]}"
			mode_contains=1
		}
	}

	# If mode keybinding doesn't contain current keypress, execute this
	((${#key_options[@]})) &&
		((mode_contains == 0)) &&
		[ -n "${key_options[else]}" ] && {
			[ "${key_options[else]}" = 'insert' ] || {
				"${key_options[else]}" && return
			}
		}

	# Do not continue if mode contains keypress to prevent control chars flooding file
	((mode_contains==1)) && return

	# If mouse is enabled, do whatever the hell that ugly piece of code does
	(("${options[mouse]}"==1)) && {
		handle-mouse "$1"
		return
	}

	# Insert the pressed character
	[[ $1 =~ [[:cntrl:]] ]] && return # If char is control char, return
	insert-word "$1"
}

function init-var {
	((options[log])) && init-log || unset buffer_log # set up log buffer (M-x log)


	log info setting traps...
	trap change-size-screen WINCH ALRM # Attach WINCH and ALRM to redraw the screen
	trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
	trap 'k_hex=(3 0); input-key' INT
	trap quit SIGTERM

	format_tab=4

	menuloc_y=0; menuloc_x=0 # menu positions
	log info 'Setting menu-line'
	toplines=${toplines:-0}
	((toplines=toplines + options[menu-line]))

	# this is reverse because the value is added to buffer redrawing size
	log info 'Setting mode-line'
	bottomlines=${bottomlines:-0}
	((options[mode-line]==0)) && ((bottomlines--))
	log info 'Setting command-line'
	((options[command-line]==0)) && ((bottomlines--))
	((bottomlines+=2))
	
	log-echo "toplines $toplines"
	log-echo "bottomlines $bottomlines"
	
	log info 'Setting reset'
	reset='\e[0;0m'
	log info 'Setting charmap'
	charmap=(
		#[0] is reserved for any unmapped char
		[	]='t' # tab
		[ ]='s' # space
	)
	if ((options[esc-to-meta])); then
		esc_timeout=123456789 # a very big number
	else
		esc_timeout=0.01
	fi
	log info 'Setting nlchar'
	nlchar='\n'
	printf '\e[?1049h'
	log info 'Setting mouse'
	((options[mouse])) && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
}

## main Main keyboard loop
function main
	while :; do
		local -a k=()
		local -i i=1
		k_hex=() # Also convert the input sequence into hex for way easier handling
		# Check for ready input
		read -rsN1 k[0] && {
			k_hex[0]="$(printf "%x\n" "'${k[0]}")"

			# Hack to try preventing arrow codes being split into multiple and inserting garbage to buffer
			[ "${k_hex[0]}" = '1b' ] && {
				read -rsN1 -t "${esc_timeout}" k[1]
				k_hex[1]="$(printf "%x\n" "'${k[1]}")"
				[ "${k_hex[1]}" = '5b' ] && {
					read -rsN1 k[2]
					k_hex[2]="$(printf "%x\n" "'${k[2]}")"
					case "${k_hex[2]}" in
						'41'|'42'|'43'|'44')
							k_hex[3]='0'
							input-key "${k[@]}"
							continue
					esac
					i=2
				}
				((i++))
			}
			# Multibyte hack
			while read -rsN1 -t0.0001 k[$i]; do
				k_hex[$i]="$(printf "%x\n" "'${k[$i]}")"
				((i++))
			done
			k_hex[$i]='0'
			input-key "${k[@]}" # Handle keypress event
		}
	done
	
