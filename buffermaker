#!/bin/bash
buffermaker_version="0.11"
log_buffer+=('' 'START')
## Buffermaker
# Pure bash tui framework (wip)

shopt -s lastpipe # For syntax highlighting
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize && (:;:) # Enable and then trigger a terminal size refresh

declare -r DEFIFS="$IFS"
declare -A highlight faces faces_raw options charmap descriptions
declare -A keys_global
declare -a k_hex buffers_l log_buffer modes=('keys_global')
declare -n buffer bf_s bf_e bf_d
declare -i menuloc_x menuloc_y hidden ismenu comment current_count _isdone
declare -n menucon
declare message reset readin

function load-default-config {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options → define-options() → ass. array options
	#				global-set → global-set-key → define-key global → as. ar. keys_global
	#				add-mode → local-set-key → define-key <keys> → a. a. keys_<keys>
	#					mode-options → local-set-mode-option → define-mode-option → a. a. key_options_<keys>
	#				set-alias → add-alias → a. a. alias
	#				add-menu → local-set-menu → define-menu <menu> → menu_<menu>_0 & menu_<menu>_1
	#				set-highlight → add-highlight → a. a. highlight
					  
	options=(
		[mouse]=0
		[todonote]=0
		[line-number-mode]=0
		[empty-line-char]=''
		[tabchar]='    '
		[keep-message]=0
		[log]=0
		[log-functions]=0
		[tty-linuxfb]=1 # enable truecolor support for framebuffer
		[full-redraw]=0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		[esc-to-meta]=0
	)
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	add-mode empty
		mode-options
			:: else :
			:: disable-global 1

	add-mode menu
		:: '[up]' menu.up
		:: '[down]' menu.down
		:: 'RET' menu.select
		mode-options
			:: else menu.exit
			:: disable-global 1

	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
default_faces=(
		reset '\e[m'
		default "$(:weight normal)"
		menu "$(:background yellow :foreground black)"
		menu-divider '\e[4m'
		menu-highlight '\e[4m\e[1m'
		menu-enabled "$(:background yellow :foreground black)"
		menu-selected "$(:background light-yellow :foreground black :weight bold)"
		button "$(:foreground light-cyan)"
		link '\e[4;96m'
		link-highlight '\e[1;4;96m'
		title "$(:weight bold)"
		highlight "$(:weight bold :foreground light-red)"
		dim "$(:weight dim)"
		name "$(:foreground magenta)"
		hint "$(:foreground light-yellow)"
		hint-highlight '\e[4;93m'
		line-number "$(:foreground gray)"
		line-number-empty "$(:weight dim :foreground gray)"
		line-number-current-line "$(:weight bold :foreground light-red)"
		tab-face "$(:weight dim :foreground gray)"
		region "$(:weight bold :background gray)"
		minibuffer-prompt "$(:weight normal)"
		#
		TODO "$(:background magenta)"
		NOTE "$(:background gray)"
		# common colors for format stuff
		black      '\e[30m' gray          '\e[90m'
		red        '\e[31m' light-red     '\e[91m'
		green      '\e[32m' light-green   '\e[92m'
		yellow     '\e[33m' light-yellow  '\e[93m'
		blue       '\e[34m' light-blue    '\e[94m'
		magenta    '\e[35m' light-magenta '\e[95m'
		cyan       '\e[36m' light-cyan    '\e[96m'
		light-gray '\e[37m' white         '\e[97m'

		bg-black      '\e[40m' bg-gray          '\e[100m'
		bg-red        '\e[41m' bg-light-red     '\e[101m'
		bg-green      '\e[42m' bg-light-green   '\e[102m'
		bg-yellow     '\e[43m' bg-light-yellow  '\e[103m'
		bg-blue       '\e[44m' bg-light-blue    '\e[104m'
		bg-magenta    '\e[45m' bg-light-magenta '\e[105m'
		bg-cyan       '\e[46m' bg-light-cyan    '\e[106m'
		bg-light-gray '\e[47m' bg-white         '\e[107m'
)
	load-theme default_faces
}

## syntaxy sugar sugary syntax
log_buffer+=('- LOADING BASH EXTENSIONS -')
function @ifs { IFS="$DEFIFS"; }
	
function copy-function {
	local -a fn
	local deffn="function $2"$'\n'
	mapfile fn <<<"$(declare -f "$1")"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
}

function ::
case "$_last_add" in
	add-menu) local-set-menu "$@";;
	set-highlight) add-highlight "$@";;
	global-set) global-set-key "$@";;
	set-options) define-option "$@";;
	add-mode) local-set-key "$@";;
	mode-options) local-set-mode-option "$@";;
	set-buffer) local-set-buffer-data "$@"
esac

## focus set magic # function
function focus {
	_last_add="$1"
}

## declare-new-buffer Create new text buffer
function declare-new-buffer {
	_last_add='set-buffer'
	((current_count++))
	set-buffer "bf_${current_count}"
	buffers_l+=("$current_buffer")
	last_line=1
	declare -Ag "${current_buffer}_bf_h"
	declare -Ag "${current_buffer}_bf_d"
	bf_d=(
		# some sane default values
		[line]=0
		[base]=1
		[column]=0
		[modified]=0
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$LINES
	)
}

function declare-buffer {
	_last_add='set-buffer'
	set-buffer "${1}" # name
	buffers_l+=("$current_buffer")
	last_line=1
	declare -Ag "${current_buffer}_bf_h"
	declare -Ag "${current_buffer}_bf_d"
	bf_d=(
		# some sane default values
		[line]=0
		[base]=1
		[column]=0
		[modified]=0
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$LINES
	)
}

## local-set-buffer-data
# set bf_d[] array of currently \"focused\" buffer
function local-set-buffer-data {
	while [ -n "$2" ]; do
		bf_d["$1"]="$2"
		shift 2
	done
}

## [auto] Checks bf_d[] array and set\'s needed missing values automatically
function [auto] {
	[ -z "${bf_d[loc-x]}" ] && bf_d[loc-x]=1
	[ -z "${bf_d[loc-y]}" ] && bf_d[loc-y]=1
	[ -z "${bf_d[size-x]}" ] && bf_d[size-x]=$COLUMNS
	[ -z "${bf_d[size-y]}" ] && bf_d[size-y]=$((LINES - 1))
	[ -z "${bf_d[syntax]}" ] && set-syntax 
}

## _ Variable refernce helper
function _ {
	# this function is here to simplify stuff as writing overlong variables indexed by overloong variable index...
	# ...is quite tiring <3
	[ -z "$1" ] && {
		for n in "${refalias[@]}"; do
			unset "$n"
		done
		unset refalias
		return
	}
	declare -gn "$1"="$2"
	refalias+=("$1")
}

## __ Swap variable references
function __ {
	# swap two references
	local -n _swap_1="$1"
	local _swap_copy_1="${!_swap_1}"
	local -n _swap_2="$2"
	local _swap_copy_2="${!_swap_2}"
	declare -gn "$1"="${_swap_copy_2}"
	declare -gn "$2"="${_swap_copy_1}"
}

## fn Shorthand for one line functions
function fn {
	[ -z "$*" ] && exit 1 # error if empty
	local name="$1"
	shift
	eval "function $name { $@; }"
}

## copy-array
# A univeral function to copy both normal and associative arrays
function copy-array {
	local -n source="$1"
	local -n target="$2"
	target=()
	for idx in "${!source[@]}"; {
		target[idx]="${source[idx]}"
	}
}

## append-array
# Append array \$1 to \$2  
function append-array {
	local -n source="$1"
	local -n target="$2"
	for idx in "${!source[@]}"; {
		target+=("${source[idx]}")
	}
}

## setface Convert colors to escape codes
# '$1' can be either one of colors:
#     black
#     red
#     green
#     yellow
#     blue
#     magenta
#     cyan
#     ligth-gray
#     gray
#     light-red
#     light-green
#     light-yellow
#     light-blue
#     light-magenta
#     light-cyan
#     white
# 'or hex. color (like "#bb2040")'
# 'or indexed 256 color with "c" as prefix (like c127)'
# 'for background color $mode has to be 48 and for foreground 38'
#
# If \$TERM \(current "$TERM"\) is \'linux\' \& option tty-linuxfb is 1 try to use true color even for tty
# Instead of normal '\e[$mode;r;g;bm' is used '\e]P$~1mode$Hexcode\e[$~2modem'
#     '$mode 38 → $~1mode 2 & $~2mode 32'
#     '$mode 48 → $~1mode 1 & $~2mode 41'
# Note that the linuxfb colors are very experimental and suffer from cursor implicitly overwriting them on movenment
function setface {
	[ -z "$1" ] && return
	case "$1" in
		black)      [ "$mode" = '38' ] && printf '\\e[30m' || printf '\\e[40m';;
		red)        [ "$mode" = '38' ] && printf '\\e[31m' || printf '\\e[41m';;
		green)      [ "$mode" = '38' ] && printf '\\e[32m' || printf '\\e[42m';;
		yellow)     [ "$mode" = '38' ] && printf '\\e[33m' || printf '\\e[43m';;
		blue)       [ "$mode" = '38' ] && printf '\\e[34m' || printf '\\e[44m';;
		magenta)    [ "$mode" = '38' ] && printf '\\e[35m' || printf '\\e[45m';;
		cyan)       [ "$mode" = '38' ] && printf '\\e[36m' || printf '\\e[46m';;
		light-gray) [ "$mode" = '38' ] && printf '\\e[37m' || printf '\\e[47m';;

		gray)          [ "$mode" = '38' ] && printf '\\e[90m' || printf '\\e[100m';;
		light-red)     [ "$mode" = '38' ] && printf '\\e[91m' || printf '\\e[101m';;
		light-green)   [ "$mode" = '38' ] && printf '\\e[92m' || printf '\\e[102m';;
		light-yellow)  [ "$mode" = '38' ] && printf '\\e[93m' || printf '\\e[103m';;
		light-blue)    [ "$mode" = '38' ] && printf '\\e[94m' || printf '\\e[104m';;
		light-magenta) [ "$mode" = '38' ] && printf '\\e[95m' || printf '\\e[105m';;
		light-cyan)    [ "$mode" = '38' ] && printf '\\e[96m' || printf '\\e[106m';;
		white)         [ "$mode" = '38' ] && printf '\\e[97m' || printf '\\e[107m';;
		*) case "${1::1}" in
			   '#')
				   if [ "$TERM" = 'linux' ] && ((options[tty-linuxfb])); then # Hack for linux framebuffer tty
					   case "$mode" in
						   38) printf '\\e]P2%s\\e[32m' "${1:1:6}" ;;
						   48) printf '\\e]P1%s\\e[41m' "${1:1:6}"
					   esac
				   else
					   local r="${1:1:2}"
					   local g="${1:3:2}"
					   local b="${1:5:2}"
					   printf '\\e[%d;2;%d;%d;%dm' "${mode}" $((16#$r)) $((16#$g)) $((16#$b))
				   fi;;
			   'c')
				   printf '\\e[%d;5;%dm' "${mode}" "${1:1}"
		   esac
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :foreground
# Set foreground color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :foreground { mode=38; setface "$@"; }

## :background
# Set background color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :background { mode=48; setface "$@"; }

## :mode Sets text mode:
# '	inverse - inverses background and foreground'
function :mode {
	case "$1" in
		inverse) printf '\\e[7m';;
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## :weight Sets thickness of text:
#     bold
#     dim
#     normal
function :weight {
	case "$1" in
		bold) printf '\\e[1m';;
		dim) printf '\\e[2m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :slant Sets slant of text:
#     italic
#     normal
function :slant {
	case "$1" in
		italic) printf '\\e[3m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## kbd Converts Emacs like key notation into hex.
function kbd {
	local -i i=0
	local out
	local in
	local -i ch=1
	# Surely there is better solution...
	ch=0
	case "${1:0:2}" in
		M-) in="${1:2:1}";;
		*) in="$1"
	esac
	((ch)) && return
	echo "$in" | {
		while read -rsn1; do
			out+="$(printf "%x\n" "'${in:$i}") "
			((i++))
		done
	}
	out=${out::-1}
	printf '%s' "${out}"
}

## define-key defines keybinding
#     '$1' can be either:
#     '[function-key]'
#     '[arrow-key]'
#     '[prior | next]'
#     'RET'
#     'DEL'
#     '[delechar]'
#     'hex code ending with 0'
function define-key {
	local -n keys="keys_$1"
	case "$2" in
		#control
		C-a) keys[1 0]="$3" ;; C-b) keys[2 0]="$3" ;;
		C-c) keys[3 0]="$3" ;; C-d) keys[4 0]="$3" ;;
		C-e) keys[5 0]="$3" ;; C-f) keys[6 0]="$3" ;;
		C-g) keys[7 0]="$3" ;; C-h) keys[8 0]="$3" ;;
		C-i) keys[9 0]="$3" ;; C-j) keys[a 0]="$3" ;;
		C-k) keys[b 0]="$3" ;; C-l) keys[c 0]="$3" ;;
		C-m) keys[d 0]="$3" ;; C-n) keys[e 0]="$3" ;;
		C-o) keys[f 0]="$3" ;; C-p) keys[10 0]="$3";;
		C-q) keys[11 0]="$3";; C-r) keys[12 0]="$3";;
		C-s) keys[13 0]="$3";; C-t) keys[14 0]="$3";;
		C-u) keys[15 0]="$3";; C-v) keys[16 0]="$3";;
		C-w) keys[17 0]="$3";; C-x) keys[18 0]="$3";;
		C-y) keys[19 0]="$3";; C-z) keys[1a 0]="$3";;
		#function keys
		'[f1]') keys[1b 4f 50 0]="$3";;
		'[f2]') keys[1b 4f 51 0]="$3";;
		'[f3]') keys[1b 4f 52 0]="$3";;
		'[f4]') keys[1b 4f 53 0]="$3";;
		'[f5]')  keys[1b 5b 31 35 7e 0]="$3";;
		'[f6]')  keys[1b 5b 31 37 7e 0]="$3";;
		'[f7]')  keys[1b 5b 31 38 7e 0]="$3";;
		'[f8]')  keys[1b 5b 32 39 7e 0]="$3";;
		'[f9]')  keys[1b 5b 32 30 7e 0]="$3";;
		'[f10]') keys[1b 5b 32 31 7e 0]="$3";;
		'[f11]') keys[1b 5b 32 33 7e 0]="$3";;
		'[f12]') keys[1b 5b 32 34 7e 0]="$3";;
		#arrow keys
		'[left]')  keys[1b 5b 44 0]="$3";;
		'[up]')    keys[1b 5b 41 0]="$3";;
		'[right]') keys[1b 5b 43 0]="$3";;
		'[down]')  keys[1b 5b 42 0]="$3";;
		#pg up & down
		'[prior]') keys[1b 5b 36 7e 0]="$3";;
		'[next]')  keys[1b 5b 35 7e 0]="$3";;
		#return
		'RET') keys[a 0]="$3";;
		#backspace & delete
		'DEL') keys[7f 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		'ESC') keys[1b 0 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		*) keys["$2"]="$3"
	esac
}

## local-set-key
# Sets keybinding of lastly defined mode
# See define-key for details
fn local-set-key 'define-key "$_last_keys" "$@"'

## global-set-key
# Sets keybinding of global mode
# See define-key for details
fn global-set-key 'define-key global "$@"'

## define-mode-option
# Sets option of mode '$1'
function define-mode-option {
	local -n ko="key_options_$1"
	ko["$2"]="$3"
}

## local-set-mode-option See define-mode-option
fn local-set-mode-option 'define-mode-option "$_last_keys" "$@"'

## mode-options Brings mode-options of lastly defined mode into \"focus\"
fn mode-options '_last_add="mode-options"'

## add-highlight Sets highlighting mode '$1' for file types '$2...'
function add-highlight {
	local name="$1"
	shift
	for i in "$@"; {
		highlight["$i"]="$name"
	}
}

## set-alias Brings into \"focus\" highlight setting
fn set-highlight '_last_add=set-highlight'

## clear-screen clears screen
fn clear-screen "printf '\033c'"

## add-mode
# Adds keybing mode
function add-mode {
	log_buffer+=("        ADD MODE $1")
	_last_keys="$1"
	_last_add='add-mode'
	modes+=("keys_$1")
	declare -Ag "keys_$1"
	declare -Ag "key_options_$1"
}

## global-set Brings into \"focus\" global mode
fn global-set '_last_add=global-set'

## define-option Defines options[] buffer
fn define-option 'options["$1"]="$2"'

## set-options Brings into \"focus\" options setting
fn set-options '_last_add=set-options'

function menu.add {
	# create new menu function & array
	eval "function @menu:${1} { menu $1; }"
	declare -ag "menu_${1}_0"
	declare -ag "menu_${1}_1"
	declare -ag "menu_${1}_2"

	local -n menu_0="menu_${1}_0"
	local -n menu_1="menu_${1}_1"
	local -n menu_1="menu_${1}_2"

	local -i c=-1
	local type
	
	local -n menu="$1"
	for i in "${menu[@]}"; do
		case "$i" in
			't:'|'text:')
				type=text
				((c++))
				continue;;
			'c:'|'cmd:'|'command:')
				type=command
				continue;;
			'f:'|'face:')
				type=face
				continue	
		esac
		case "$type" in
			'text')
				menu_0[c]+=" $i"
				;;
			'command')
				menu_1[c]+="$i "
				;;
			'face')
				menu_2[c]+="$i"
		esac
	done
	menu.layout "$1"
}
function menu.layout {
	local -n menu_0="menu_${1}_0"
	local -i max=0
	for i in "${menu_0[@]}"; do
		((${#i} > max)) && max="${#i}"
	done
	for i in "${!menu_0[@]}"; do
		for ((l=$((max - ${#menu_0[i]})) + 1; l>0; l--)); do
			menu_0[i]+=' '
		done
	done
}

## load-theme Loads theme from array
function load-theme {
	local -i t=0
	local k
	local -n theme="$1"
	for i in "${theme[@]}"; {
		((t==0)) && {
			k="$i"
			t=1
		} || {
			faces["$k"]="$i"
			faces_raw["$k"]="$(printf '%b' "$i")"
			t=0
		}
	}
	((t)) && errno=1 die
}

## rest of this garbageware

## refresh Refreshes buffer
# 'clears screen, reset syntax, redraws'
# 'See <a> doc-goto clear-screen : <f> link clear-screen </f> </a> for more info.'
function refresh {
	clear-screen
	bf_s=''
	
	message="reloaded..."
	redraw
}

## switch-mode
# Change current mode of buffer into '$1'
function switch-mode {
	bckmode="${bf_d[mode]}"
	bf_d[mode]="$1"
}

## mode-back
# Restores previous mode
function mode-back {
	bf_d[mode]="$bckmode"
	unset bckmode
}

## read-command
# Works like normal "'read'" but for bottom commanline
function read-command {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	read -re -p "$1" -i "$3" "$2" || return 1
}

## base-name
# Basically equivalent to the "'basename'" coreutil		
function base-name
	for file in "$@"; {
		file="${file%/}"
		printf '%s\n' "${file##*/}"
	}

### TODO: make this make sense

## make-render Creates syntax highlighting for currently visible lines
function make-render {
	make-render-area "${bf_d[base]}" $((bf_d[base] + bf_d[size-y] + bf_d[loc-y]))
}

## make-render-area
# Creates syntax highlighting for lines from '$1' to '$2'
function make-render-area {
    local -i line="$1"
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	for ((l=syntaxline;l<${2};l++)); do
		((l > $2)) && break
		local -n linearray="${current_buffer}_syntax${syntaxline}"
		linearray=()
		bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
		((syntaxline++))
		line="$l"
		case "${bf_d[render-type]}" in
			'per-char') make-render-line-loop-char;;
			'per-word') make-render-line-loop;;
			*) make-render-line-loop
		esac
	done
	IFS="$bckeIFS"
}
	
## make-render-line
# Syntax highlights single line '$1'
# Defaults to currently selected line if no argument is passed
function make-render-line {
	local -i line=${1:-bf_d[line]}
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	case "${bf_d[render-type]}" in
		'per-char') make-render-line-loop-char;;
		'per-word') make-render-line-loop;;
		*) make-render-line-loop
	esac
	IFS="$bckeIFS"
}

function make-render-line-loop {
	local -i comment=0
	local -i skip_next_space=0
	local word=''
	bf_e[line]=''

	for _link in ${bf_c[line]}; do
		unset "$_link"
	done
	unset bf_c[line]
		
	column=0
	IFS=' '
	while read -rs word; do
		IFS=''
		syntax-word
		IFS=' '
	done  <<< "${buffer[line]}"
}

## make-render-line-loop
# Backend for make-render-area \& make-render-line
# Also creates bf_e charmap for movenment
#     "Tab is 't'"
#     "Space is 's'"
#     "Any unmaped char is '0'"
function make-render-line-loop-char {
	local -i comment=0
	local -i skip_next_space=0
	local word=''
	bf_e[line]=''

	for _link in ${bf_c[line]}; do
		unset "$_link"
	done
	unset bf_c[line]
		
	column=0
	while read -rsn1 char; do	
		case "$char" in
			' ')
				syntax-word
				word=''
				((skip_next_space==1)) && skip_next_space=0 && continue
				bf_e[line]+='s'
				face-no-expand "${facename:-${bf_d[background]:-default}}" ' '
				((column++));;
			'	')
				syntax-word
				word=''
				local -i i
				for ((i = ${#options[tabchar]}; i > 0 ; i--)); do
					bf_e[line]+="${charmap[	]}"
				done
				face-no-expand tab-face "${options[tabchar]}"
				((column+=${#options[tabchar]}));;
			'')
				syntax-word
				word=''
				skip_next_space=0
				face-no-expand "${bf_d[background]:-default}" ' '
				newline=1 # tell syntax functions that the previous char was newline # used for format thing
				return;;
			*)
				word+="${char}"
		esac
	done  <<< "${buffer[line]}"
}

## syntax-word
# Decides what a word should highlighted as:
#     'If todonote option is enabled, highlight "NOTE:" & "TODO:"'
#     'If the word is supposed to be comment highlight it as it'
#     'Else pass it to current syntax function'
function syntax-word {
	(("${options[todonote]}"==1)) && {
		case "$word" in
			'NOTE:') face NOTE "${word}"; return ;;
			'TODO:') face TODO "${word}"; return ;;
		esac
	}
	((comment)) && set-face font-lock-comment-face ||
		"${bf_d[syntax]}"
	((bf_d[syntax-exec])) || face "$syntax_face" "$word" # s_ex controls syntax extended
}

## face
# Add highlighted word to multidimensional nonsense "'bf_s'" arry
function face {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
	for ((iw=0; iw < ${#2}; iw++)); do
		bf_e[line]+='0'
	done
}

## face-no-expand
# Add highlighted word to multidimensional nonsense "'bf_s'" arry without adding anything to bf_e[] array
function face-no-expand {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
}

## set-face Sets face for syntax highlighting
fn set-face 'syntax_face="$1"'

## size-full
# Sets size of buffer to be fullscreen
function size-full {
	bf_d+=(
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$LINES
	)
}

## set-buffer
# Switch to buffer \$1 
function set-buffer {
	log info "switch to buffer [$1]"
	current_buffer="$1"
	declare -ng buffer="${current_buffer}_buffer"
	declare -ng bf_s="${current_buffer}_bf_s"
	declare -ng bf_e="${current_buffer}_bf_e"
	declare -ng bf_d="${current_buffer}_bf_d"
	declare -ng bf_c="${current_buffer}_bf_c"
	declare -ng bf_h="${current_buffer}_bf_h"
}

## add-to-list
# Adds a buffer into currently active buffer list
function add-to-list {
	log info "added into buffer list: $current_buffer"
	buffers_l+=("$current_buffer")
}

## clear-buffer
# Empties buffer bf_s bf_e \& bf_d
function clear-buffer {
	buffer=()
	for l in "${bf_s[@]}"; {
		unset "$l"
	}
	bf_s=()
	bf_e=()
	for l in "${bf_c[@]}"; {
		unset "$l"
	}
	bf_c=()
}

## list-directory
# Basically like ls command 
function list-directory {
	((hidden==1)) && shopt -s dotglob
	((hidden==0)) && shopt -u dotglob
	printf '..\n'
	printf '%s\n' *
}

## current-time
# Basically like coreutil "'date'"
fn current-time 'printf "%($1)T\\n"'

## log
# Adds message into log
# '    info -- everything *should* be well'
# '    warn -- something is wrong but it *should* not break entire Ebashs'
# '    error -- something is wrong and anything can break, but it *can* still run(?)'
# '    fatal -- something is mega wrong and only thing left to do is to die'
# Is disabled when log wasn\'t initialised, see init-log for info
function log {
	((log)) || return
	local type="$1"
	shift
	tooktime="$(( $(current-time '%s') - lasttime ))"
	bufferlog+=("<f> title [$type] </f> <f> font-lock-comment-face ${tooktime}s </f> <f> name [${FUNCNAME[1]}] </f> $*")
	lasttime="$(current-time '%s')"
}

## log-echo
# Adds message into log without any special formating	
function log-echo {
	((log)) || return
	bufferlog+=("<f> font-lock-comment-face > </f>    $*")
}

## debug
# +debug -- basically like set -x but reports stuff into log
## +log	
# Debug function to add logging to function it\'s called from
function +log {
	((log)) || return
	((options[log-functions])) && log '*' "${FUNCNAME[1]}"
	trap 'log bash $? $LINENO ${BASH_COMMAND}' ERR
}
## +debug
# Debug function to add extensive \(set -x like\) logging to function it\'s called from
function +debug {
	((log)) || return
	trap 'log DEBUG "${BASH_COMMAND}"' DEBUG
}

## goto Load array into buffer
function goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
	copy-array "$1" buffer
	redraw
}

function syntax-format {
	((skip_word==1)) && {
		skip_next_space=1
		[ "$word" = '-->' ] && skip_word=0
		return
	}
	[ "$word" = '<!--' ] && {
		skip_next_space=1
		skip_word=1
		return
	}
	((newline==1)) && {
		ichar="${indent_spaces}"
	}
	((newline==0)) && {
		ichar=
	}

	((escape==2)) && {
		escape=1
		facename="$word"
		skip_next_space=1
		return
	}
	((escape==1)) && {
		escape=0
		face "$facename" "${ichar}$word"
		return
	}
	[ "$word" = '<\>' ] && {
		escape=1
		skip_next_space=1
		facename='unknown'
		return
	}
	[ "$word" = '<[>' ] && {
		escape=2
		skip_next_space=1
		return
	}
	
	((variable==1)) && {
		variable=0
		word="${!word}"
	}
	[ "$word" = '<v>' ] && {
		variable=1
		varname=
		skip_next_space=1
		return
	}

	[ "$word" = '</u>' ] && {
		upper=0
		skip_next_space=1
		return
	}
	[ "$word" = '<u>' ] && {
		upper=1
		skip_next_space=1
		return
	}
	[ "$word" = '</f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '</f->' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		skip_next_space=1
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	((facedef==1)) && {
		skip_next_space=1
		facedef=0
		facename="$word"
		return
	}
	[ "$word" = '<f>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	[ "$word" = '<-f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	
	[ "$word" = '</h>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		upper=0
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<h>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=title
		upper=1
		return
	}
	
	((sethighlight==2)) && {
		sethighlight=1
		skip_next_space=1
		tmp_sex="$word"
		return
	}
	((sethighlight==1)) && {
		sethighlight=0
		skip_next_space=1
		bf_d[syntax-exec]="$tmp_sex"
		bf_d[syntax]="syntax-$word"
		return
	}
	[ "$word" = '<change-syntax>' ] && {
		skip_next_space=1
		sethighlight=2
		return
	}
	((space_next==1)) && {
		space_next=0
		skip_next_space=1
		for ((if=0; if< word; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '<s>' ] && {
		space_next=1
		skip_next_space=1
		return
	}
	[ "$word" = '<tab>' ] || [ "$word" = '<->' ] && {
		skip_next_space=1
		for ((if=0; if< format_tab; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '</i>' ] && {
		indent_spaces=
		return
	}
	((indent==1)) && {
		indent=0
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< word; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	[ "$word" = '<i>' ] && {
		indent=1
		skip_next_space=1
		return
	}
	[ "$word" = '<i-tab>' ] && {
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< format_tab; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	((link==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				link=1
			))
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</a>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		return
	}
	[ "$word" = '<a>' ] && {
		((
			link=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	((facelink==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				facelink=1
			))
			facename='link'
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</link>' ] && {
		((lc++))
		((column--))
		facelink=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<link>' ] && {
		((
			facelink=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	
	((object==1)) && {
		skip_next_space=1
		[ "$word" = 'text:' ] && {
			object=0
			set_obj=0
			return
		}
		[ "$word" = 'select:' ] && { set_obj=1; obj_select=; return; }
		[ "$word" = 'id:' ] && { set_obj=2; obj_id=; return; }
		[ "$word" = 'left:' ] && { set_obj=3; obj_left=; return; }
		[ "$word" = 'up:' ] && { set_obj=4; obj_up=; return; }
		[ "$word" = 'right:' ] && { set_obj=5; obj_right=; return; }
		[ "$word" = 'down:' ] && { set_obj=6; obj_down=; return; }

		((set_obj==1)) && obj_select+="$word "
		((set_obj==2)) && obj_id+="$word "
		((set_obj==3)) && obj_left+="$word "
		((set_obj==4)) && obj_up+="$word "
		((set_obj==5)) && obj_right+="$word "
		((set_obj==6)) && obj_down+="$word "
		return
	}
	[ "$word" = '</o>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$obj_select"
			[id]="$obj_id"
			[left]="$obj_left"
			[up]="$obj_up"
			[right]="$obj_right"
			[down]="$obj_down"
		)
		return
	}
	[ "$word" = '<o>' ] && {
		((
			object=1,
			lsx=column,
			skip_next_space=1
		))
		obj_id=
		obj_text=
		obj_select='true'
		obj_left='backward-char'
		obj_up='previous-line'
		obj_right='forward-char'
		obj_down='next-line'
		set_obj=0
		return
	}
	
	((newline==1)) && newline=0
	((column+=${#ichar} + ${#word}))
	((upper==1)) && {
		word="${word^^}"
	}
	face "${facename:-unknown}" "${ichar}$word"
}

function link-enter {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"		
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				has=1
				${bf_c_line[exec]}
				return
			}
	}
	${bf_d[format-else]}
}

function format-left {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[left]:-backward-char}
				return
			}
	}
	backward-char
}
function format-up {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[up]:-previous-line}
				return
			}
	}
	previous-line
}
function format-right {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[right]:-forward-char}
				return
			}
	}
	forward-char
}
function format-down {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[down]:-next-line}
				return
			}
	}
	next-line
}

function obj {
	for y in "${!bf_c[@]}"; {
		for obj in ${bf_c[y]}; {
			local -n bf_c_line="$obj"
			[ "${bf_c_line[id]}" = "$1 " ] && {
				((bf_d[line]=y, bf_d[column]=bf_c_line[start]))
				redraw.cursor
			}
		}
	}
}
	
fn is-function 'declare -F -- "$1" > /dev/null'

## Dumps current buffer into a file	
function dump-buffer {
	true >"$1" # Set the file to an empty text file
	for ln in "${buffer[@]}"; do # Write in the buffer to the file
		echo "$ln" >>"$1"
	done
}

## die
# Closes Ebashs with exit code \$errno, if errno is empty exit with 0
# If \$nocleanup is 1, do not restore the terminal to sane mode and do not cleanup 
# Else restore to sane mode 
function die {
	((nocleanup)) && exit "${errno:-0}"
	${on_die:-true}
	echo -e "\e[?1000;1006;1015l" #disable mouse tracking
	clear-screen # TODO fix the buffer switching
	printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
	exit "${errno:-0}" # Assume that we are exiting without an error
}

# Sets \$nocleanup to 1 and dies	
function die.force {
	((nocleanup=1)) && die "$@"
}

function move.previous-line.check ((bf_d[line] > 1))
function move.next-line.check ((bf_d[line] < ${#buffer[@]}+bf_d[last-newline]))

# Moves up \$1 lines, if \$ is empty move up 1 line
function move.previous-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] > 1)) && ((bf_d[line]--))
		((bf_d[line] < bf_d[base] + 1)) && {
			((bf_d[base]--)) # Push back the top if we need to
			move_base=1 # Send signal to redraw.cursor that the buffer was moved, thus needs to be redraw fully
			((bf_d[base] <= 0)) && bf_d[base]=1 # Don't push back if our base is at 1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

# Moves down \$1 lines, if \$ is empty move down 1 line
function move.next-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] < ${#buffer[@]}+bf_d[last-newline])) && ((bf_d[line]++))
		# Move window down if needed
		((bf_d[line] > bf_d[base] + bf_d[size-y] - 3)) && {
			((bf_d[base]++))
			move_base=1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

function previous-line {
	move.previous-line.check || return
	hook pre-move
	move.previous-line "$@"
	hook move
	redraw.cursor
}
function next-line {
	move.next-line.check || return
	hook pre-move
	move.next-line "$@"
	hook move
	redraw.cursor
}
function scroll-down {
	hook pre-move
	move.previous-line $((bf_d[size-y] - 3))
	hook move
	redraw.cursor
}
function scroll-up {
	hook pre-move
	move.next-line $((bf_d[size-y] - 3))
	hook move
	redraw.cursor
}
	
fn move-beginning-of-line 'bf_d[column]=0; redraw'
fn move-end-of-line 'bf_d[column]="${#bf_e[${bf_d[line]}]}"; redraw'

function forward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}+1:1}" in
			't') bf_d[column]=$(( bf_d[column]+${#options[tabchar]}));;
			*) ((bf_d[column]++));;
		esac
		((bf_d[column] > ${#bf_e[${bf_d[line]}]})) && {
			bf_d[column]=0
			next-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-line.cursor
	fi
}

function backward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}-1:1}" in
			't') bf_d[column]=$(( bf_d[column]-${#options[tabchar]}));;
			*) ((bf_d[column]--));;
		esac
		((bf_d[column] < 0)) && ((bf_d[line]==1)) && {
			bf_d[line]=1
			bf_d[column]=0
		}
		((bf_d[column] < 0)) && {
			bf_d[column]="${#bf_e[${bf_d[line]}-1]}"
			previous-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-line.cursor
	fi
}
	
## forward-word
# Moves forward to next word
function forward-word {
	((bf_d[column] == ${#bf_e[bf_d[line]]})) && {
		next-line
		move-beginning-of-line
	}
	while :; do
		((bf_d[column] < ${#bf_e[bf_d[line]]})) && ((bf_d[column]++)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}

## backward-word
# Moves backward to previous word
function backward-word {
	((bf_d[column] == 0)) && {
		previous-line
		move-end-of-line
	}
	while :; do
		((bf_d[column] > 0)) && ((bf_d[column]--)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}


#Move cursor to line number $1 and move the line into middle of visible buffer area.
function to-line {
	bf_d[line]="$1"
	bf_d[base]=$((bf_d[line] - bf_d[size-y] / 2 ))
	redraw
}

# Redraw popup menu
function redraw.menu {
	printf '\e[?25l' # hide cursor (again)
	printf '\e[%s;0H' "${bf_d[line]}" #$menuloc_y
	for i in "${!menu_0[@]}"; {
		if ((i == menuselection)); then
			printf "\e[%sC%b%s${reset}\n" "${bf_d[column]}" "${faces[menu-selected]}${faces_raw[${menu_2[i]:-menu-selected}]}" "${menu_0[i]}"
		else
			printf "\e[%sC%b%s${reset}\n" "${bf_d[column]}" "${faces[menu-enabled]}${faces_raw[${menu_2[i]:-menu-enabled}]}" "${menu_0[i]}"
		fi
	}
}


function menu.up {
	((menuselection > 0)) && ((menuselection--));
	redraw.menu;
}
function menu.down {
	((menuselection < ${#menu_0[@]} -1)) && ((menuselection++));
	redraw.menu;
}

# Execute selected item in menu
function menu.select
for i in "${!menu_1[@]}"; {
	((i == menuselection)) && ${menu_1[i]}
}

# Closes a menu
function menu.exit {
	ismenu=0
	bf_d[mode]="${modebackup}"
	redraw
}

# Opens a menu \$1	
function menu {
	declare -ng menu_0=menu_${1}_0
	declare -ng menu_1=menu_${1}_1
	declare -ng menu_1=menu_${1}_2
	((ismenu == 0 )) && modebackup="${bf_d[mode]}"
	ismenu=1
	declare -ig menuselection=0
	bf_d[mode]='menu'
	redraw
}

# deletes current buffer
function delete-buffer {
	local -a copy
	local i=0
	local index
	for b in "${buffers_l[@]}"
	do
		[[ "$b" != "$current_buffer"  ]] && copy+=("$b")
		[[ "$b" = "$current_buffer"  ]] && index="$i"
		((i++))
	done
	unset buffers_l
	copy-array copy buffers_l
	current_buffer="${buffers_l[index-1]}"
	redraw
}

# Handle changing size of terminal
function change-size-screen {
	bf_d[size-x]="$COLUMNS"
	bf_d[size-y]=$((LINES-1))
	redraw
}
	
## redraw
# Redraw screen
function redraw {
	@hook begin && return
	redraw.content
	redraw.cursor
}

## hooks
# stored in bf_h ass. array
# naming scheme is '<function> <name>', function name is handled automatically when defining a hook via @hook
function @hook {
	local name="${FUNCNAME[1]} $1"
	shift
	[ -n "${bf_h[${name}]}" ] && {
		"${bf_h[${name}]}" "$@"
		return 0
	}
	return 1
}
# common hooks, without function prefix
function hook {
	local name="$1"
	shift
	[ -n "${bf_h[${name}]}" ] && {
		"${bf_h[${name}]}" "$@"
		return 0
	}
	return 1
}


function linenum.begin {
	# Get length of line-number of lines
	bf_d[length]="${#buffer[@]}"
	((bf_d[length]==0)) &&((bf_d[length]++))
	
	bf_d[number-length]=${#bf_d[length]}
	bf_d[number-space]=1
}
function linenum.loop-begin {
	space=1
	ln="\e[%dG%b%*s"
	lnargs=(
		"${bf_d[loc-x]}"
		"${faces[line-number]}"
		"${bf_d[number-length]}"
		"$i"
	)
	((i == bf_d[line])) && lnargs[1]="${faces[line-number-current-line]}"
}
function linenum.update {
	printf '\e[%s;%sH%b%*s\e[m'\
		   $((last_line + options[menu-line] - bf_d[base] + bf_d[loc-y]))\
		   "${bf_d[loc-x]}"\
		   "${faces[line-number]}"\
		   ${bf_d[number-length]}\
		   $last_line
	printf '\e[%s;%sH%b%*s\e[m'\
		   $y\
		   "${bf_d[loc-x]}"\
		   "${faces[line-number-current-line]}"\
		   ${bf_d[number-length]}\
		   ${bf_d[line]}
}

function set-linenum {
	bf_h[redraw.content begin]=linenum.begin
	bf_h[redraw.content loop-begin]=linenum.loop-begin
	bf_h[redraw.cursor pre-redraw]=linenum.update
}

function redraw.content {
	printf '\e[?25l'
	
	# the first line should be always empty 
	unset buffer[0]

	((bf_d[number-length]=0, bf_d[number-space]=0))
	
	@hook begin
	
	# Move the buffer horizontally if needed
	((bf_d[column] +3 < bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=0
	((bf_d[column] +3 > bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=$((bf_d[column] - (bf_d[size-x] + bf_d[loc-x] - bf_d[number-length] - 1) +3))

	printf "\e[%s;%sH" "${bf_d[loc-y]}" "${bf_d[loc-x]}"
	
	# IFS has to be empty in order to bufferarray multiarray be printed as words instead of chars
	IFS=''

	# Handle line number displaying
	# the resulting line has to be printed in one go to prevent flicker
	# space stores if the position of actuall text should be offset by +1
	# ln stores printf print line
	# args stores printf arguments
	local -i space
	local ln
	local -a lnargs
	
	# Iterate over shown lines
	local -i max=$((bf_d[size-y]))
	for ((i = bf_d[base]; i - bf_d[base] < max; i++)); do
	# if the line is last, do not add newline

		ln="\e[%dG"
		lnargs=(
			"${bf_d[loc-x]}"
		)
		@hook loop-begin
		
		((i - bf_d[base] > max - 2)) && nlchar='' || nlchar='\n'

		((i > ${#buffer[@]})) &&
			printf '\e[%sG%b%*s%s%b%*s%b'\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number-empty]}"\
				   $((bf_d[number-length]/2)) ''\
				   "${options[empty-line-char]}"\
				   "${faces[default]}"\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   "$nlchar" &&
			continue
		
		# to improve speed syntaxing has to be "lazy" -- having to be heavily cached as ram is far less expensive to waste
		[ -z "${bf_s[base+i]}" ] && {
			make-render-line $((base + i))
		}
		local -n linearray="${bf_s[i]}"
		
		# due to escape codes present in bf_s,
		# the bf_s has to be multidimensional nonsense for perfomance reasons
		printf "${ln}%b%*s\e[%sG%b%s\e[m%b"\
			   ${lnargs[@]}\
			   "${faces[${bf_d[background]:-default}]}"\
			   $((bf_d[size-x] - bf_d[number-length]))\
			   ''\
			   $((bf_d[loc-x] + bf_d[number-length] + space))\
			   "${faces[${bf_d[background]:-default}]}"\
			   "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"\
			   "$nlchar"
	done
	@ifs
	# redraw menu if open
	[ "${bf_d[mode]}" = 'menu' ] && redraw.menu
}

## print-buffer-line
function print-buffer-line {
	IFS=''
	# why this errors when stderr is redirected
	local -n linearray="${bf_s[bf_d[line]]}"
	printf '%s' "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"
	@ifs
}

# Draw cursor on the line
function redraw-line.cursor {
	((options[full-redraw]==0)) && {
		# redraw if buffer needs to be moved horizontally
		((bf_d[column] > bf_d[size-x] - bf_d[number-lenght] - space)) && {
			redraw
			return
		}
		((bf_d[basecolumn]==0)) || {
			redraw
			return
		}
		printf '\e[%sG\e[?25h'\
			   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space])) ||
			redraw
	}
}
	
# Draw cursor and if move_base is 1 redraw
function redraw.cursor {
	@hook first && return
	((move_base)) && {
		move_base=0
		redraw
		return
	}
	local -i y=$((bf_d[line] + options[menu-line] - bf_d[base] + bf_d[loc-y]))
	@hook pre-redraw
	printf '\e[%s;%sH\e[?25h'\
		   $y\
		   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space]))
	last_line=${bf_d[line]}
	@hook post-redraw
}

function cursor.hide {
	printf '\e[?25l'
}
function cursor.show {
	printf '\e[?25h'
}

## keypress.mouse
# Handle mouse click
function keypress.mouse {
	local -i x y
	#parse mouse stuff somewhatish weirdly
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
	((skipnext==1)) && skipnext=0 && return
	((skipnext==0)) && [ "${k_hex[*]:0:2}" = '1b 5b' ] && {
		mapfile -t -d '' inputarray <<< "${1}"
		inputarray[-1]="${inputarray[-1]%?}"
		[ -z "${inputarray[2]}" ] && skipnext=1
		mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
		inputarray[-1]="${inputarray[-1]%?}"	
		mousemode="${inputarray[0]}"
		x="${inputarray[1]}"
		y="${inputarray[2]::-1}"
		#limitations of movenment
		#TODO:
		((x < (bf_d[number-length] + bf_d[loc-x] + 2))) && {
			if [ "$mousemode" = '[<0' ]; then
				bf_d[line]=$(( bf_d[base] + (y - bf_d[loc-y]) ))
				redraw
			elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
				clear-screen
				echo 'Enter the index: '
				read -re line
				redraw
			fi
			return
		}
		bf_d[line]=$(( bf_d[base] + ( y - bf_d[loc-y] - 1) ))
		bf_d[column]=$(( x - (bf_d[loc-x] + bf_d[number-length] + 1) ))
		((bf_d[line] > ${#bf_e[@]})) &&
			bf_d[line]=${#bf_e[@]}
		((bf_d[column] > ${#bf_e[bf_d[line]]})) &&
			bf_d[column]=${#bf_e[bf_d[line]]}
		redraw
	}
}

## insert-word
# Insert \$1 to buffer
function insert-word {
	((options[save-states])) && save-state
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
	buffer[bf_d[line]]="${buffer[${bf_d[line]}]:0:${rlr}}$1${buffer[${bf_d[line]}]:${rlr}}"
	#add at cursor position - amount of tabs * tab size
	make-render-line
	forward-char "${#1}"
	bf_d[selection]=0
	redraw
	bf_d[modified]=1
}

## keypress Handles input
# Either \$1 raw character input or k_hex array containing hex values of characters is used
function keypress {
	#arg $1 is the pressed key in normal text form
	#k_hex is pressed key in hex array ending with 0
		
	local -i mode_contains=0
	local -n modekeys="keys_${bf_d[mode]}"\
	         key_options="key_options_${bf_d[mode]}"

	# global keys
	((key_options[disable-global])) ||
		for str in "${!keys_global[@]}"
		{
			[ "$str" = "${k_hex[*]}" ] && {
				"${keys_global[$str]}"
				return
			}
		}

	# Execute the 'always' key option
	((${#key_options[@]})) &&
		[ -n "${key_options[always]}" ] && "${key_options[always]}"

	# Loop over current mode keybindings to match current keypress
	for str in "${!modekeys[@]}"
	{
		[ "$str" = "${k_hex[*]}" ] && {
			"${modekeys[$str]}"
			mode_contains=1
		}
	}

	# If mode keybinding doesn't contain current keypress, execute this
	((${#key_options[@]})) &&
		((mode_contains == 0)) &&
		[ -n "${key_options[else]}" ] && {
			[ "${key_options[else]}" = 'insert' ] || {
				"${key_options[else]}" && return
			}
		}

	# Do not continue if mode contains keypress to prevent control chars flooding file
	((mode_contains==1)) && return

	# If mouse is enabled, do whatever the hell that ugly piece of code does
	(("${options[mouse]}"==1)) && {
		keypress.mouse "$1"
		return
	}

	# Insert the pressed character
	[[ $1 =~ [[:cntrl:]] ]] && return # If char is control char, return
	insert-word "$1"
}

function init-var {
	((options[log])) && init-log || unset buffer_log # set up log buffer (M-x log)


	log info setting traps...
	trap change-size-screen WINCH ALRM # Attach WINCH and ALRM to redraw the screen
	trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
	trap 'k_hex=(3 0); keypress' INT
	trap quit SIGTERM

	format_tab=4
	
	log info 'Setting reset'
	reset='\e[0;0m'
	log info 'Setting charmap'
	charmap=(
		#[0] is reserved for any unmapped char
		[	]='t' # tab
		[ ]='s' # space
	)
	if ((options[esc-to-meta])); then
		esc_timeout=123456789 # a very big number
	else
		esc_timeout=0.01
	fi
	log info 'Setting nlchar'
	nlchar='\n'
	printf '\e[?1049h'
	log info 'Setting mouse'
	((options[mouse])) && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
}

## main Main keyboard loop
function input-loop
	while :; do
		local -a k=()
		local -i i=1
		k_hex=() # Also convert the input sequence into hex for way easier handling
		# Check for ready input
		read -rsN1 k[0] && {
			k_hex[0]="$(printf "%x\n" "'${k[0]}")"

			# Hack to try preventing arrow codes being split into multiple and inserting garbage to buffer
			[ "${k_hex[0]}" = '1b' ] && {
				read -rsN1 -t "${esc_timeout}" k[1]
				k_hex[1]="$(printf "%x\n" "'${k[1]}")"
				[ "${k_hex[1]}" = '5b' ] && {
					read -rsN1 k[2]
					k_hex[2]="$(printf "%x\n" "'${k[2]}")"
					case "${k_hex[2]}" in
						'41'|'42'|'43'|'44')
							k_hex[3]='0'
							keypress "${k[@]}"
							continue
					esac
					i=2
				}
				((i++))
			}
			# Multibyte hack
			while read -rsN1 -t0.0001 k[$i]; do
				k_hex[$i]="$(printf "%x\n" "'${k[$i]}")"
				((i++))
			done
			k_hex[$i]='0'
			keypress "${k[@]}" # Handle keypress event
		}
	done
	
